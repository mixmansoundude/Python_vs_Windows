# yamllint disable rule:line-length rule:truthy
---
name: Codex - Auto Iterate on CI Failure

on:
  workflow_run:
    workflows:
      - Batch syntax/run check
    types:
      - completed

permissions:
  contents: write
  actions: read
  pull-requests: write
  pages: write

env:
  MAX_ATTEMPTS: '4'
  CODEX_MODEL: codex-gpt-5
  MINI_MODEL: gpt-4o-mini

jobs:
  noop:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Upstream succeeded
        run: |
          {
            echo '### Codex auto-iterate';
            echo '- upstream run: ${{ github.event.workflow_run.id }} (attempt ${{ github.event.workflow_run.run_attempt }})';
            echo '- conclusion: success';
            echo '- action: skipped (nothing to do)';
          } >> "$GITHUB_STEP_SUMMARY"

  iterate:
    if: ${{ github.event.workflow_run.conclusion != 'success' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
      pull-requests: write
      pages: write
    env:
      SOURCE_RUN_ID: ${{ github.event.workflow_run.id }}
      SOURCE_RUN_ATTEMPT: ${{ github.event.workflow_run.run_attempt }}
      SOURCE_HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
      SOURCE_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
      SOURCE_EVENT: ${{ github.event.workflow_run.event }}
    outputs:
      codex_log: ${{ steps.attempts.outputs.log_path }}
      preflight_ok: ${{ steps.preflight.outputs.ok || 'false' }}
      diagnostics_dir: ${{ steps.diag_bundle.outputs.dir }}
      diag_manifest: ${{ steps.diag_bundle.outputs.manifest }}
      diagnostics_url: ${{ steps.nudge.outputs.public_url }}
      commit_pushed: ${{ steps.attempts.outputs.commit_pushed || 'false' }}
    steps:
      - name: Derive context
        id: ctx
        run: |
          set -euo pipefail
          branch="${{ github.event.workflow_run.head_branch }}"
          if [ -z "$branch" ] || [ "$branch" = "null" ]; then
            branch="${{ github.event.workflow_run.head_commit.ref || 'unknown' }}"
          fi
          slug=$(printf '%s' "$branch" | tr ':/ ' '---' | tr -c 'A-Za-z0-9._-' '-')
          head_repo="${{ github.event.workflow_run.head_repository.full_name || github.repository }}"
          target_repo="${{ github.repository }}"
          can_push='false'
          if [ "$head_repo" = "$target_repo" ]; then
            can_push='true'
          fi
          html_url='${{ github.event.workflow_run.html_url }}'
          {
            echo "branch=$branch"
            echo "branch_slug=$slug"
            echo "head_repo=$head_repo"
            echo "target_repo=$target_repo"
            echo "can_push=$can_push"
            echo "run_url=$html_url"
          } >> "$GITHUB_OUTPUT"
          {
            echo '### Codex auto-iterate'
            echo "- upstream run: ${{ github.event.workflow_run.id }} (attempt ${{ github.event.workflow_run.run_attempt }})"
            echo "- conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "- event: ${SOURCE_EVENT}"
            echo "- branch: $branch"
            echo "- head repo: $head_repo"
            echo "- push eligible: $can_push"
            if [ -n "$html_url" ] && [ "$html_url" != 'null' ]; then
              echo "- run URL: $html_url"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}
          fetch-depth: 0
          persist-credentials: true

      - name: Configure branch tracking
        if: ${{ steps.ctx.outputs.can_push == 'true' }}
        run: |
          set -euo pipefail
          branch='${{ steps.ctx.outputs.branch }}'
          git checkout -B "$branch" "$SOURCE_HEAD_SHA"
          git remote -v

      - name: Configure git identity
        if: ${{ steps.ctx.outputs.can_push == 'true' }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: List upstream artifacts
        id: artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const runId = Number(process.env.SOURCE_RUN_ID);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const { data } = await github.rest.actions.listWorkflowRunArtifacts({
              owner,
              repo,
              run_id: runId,
              per_page: 100,
            });
            const records = (data.artifacts || [])
              .filter(art => !art.expired)
              .map(art => ({
                id: art.id,
                name: art.name,
                size_in_bytes: art.size_in_bytes,
                url: art.archive_download_url,
                created_at: art.created_at,
                updated_at: art.updated_at,
              }));
            const payload = { run_id: runId, count: records.length, artifacts: records };
            const fs = require('fs');
            fs.writeFileSync('upstream_artifacts.json', JSON.stringify(payload, null, 2));
            core.setOutput('json', JSON.stringify(payload));

      - name: Download diagnostics URL artifact
        id: diag_url_art
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          run-id: ${{ env.SOURCE_RUN_ID }}
          pattern: codex_nudge_url-*-${{ env.SOURCE_RUN_ID }}-${{ env.SOURCE_RUN_ATTEMPT }}
          merge-multiple: true
          path: ${{ runner.temp }}/upstream-nudge

      - name: Resolve diagnostics URL
        id: nudge
        run: |
          set -euo pipefail
          base="$RUNNER_TEMP/upstream-nudge"
          url_file=""
          if [ -d "$base" ]; then
            url_file=$(find "$base" -type f -name 'codex_nudge_url.txt' -print -quit)
          fi
          public_url=""
          if [ -n "$url_file" ]; then
            public_url=$(head -n 1 "$url_file" | tr -d '\r')
          fi
          if [ -z "$public_url" ]; then
            public_url=''
          fi
          printf 'public_url=%s\n' "$public_url" >> "$GITHUB_OUTPUT"
          {
            echo "- upstream diagnostics URL: ${public_url:-'(not published)'}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Prepare nudge bundle
        id: prep_nudge
        run: |
          set -euo pipefail
          nudge_root="$RUNNER_TEMP/nudge"
          dest="$RUNNER_TEMP/nudge/${SOURCE_RUN_ID}-${SOURCE_RUN_ATTEMPT}"
          mkdir -p "$nudge_root"
          branch='${{ steps.ctx.outputs.branch }}'
          run_url='${{ steps.ctx.outputs.run_url }}'
          diag_url='${{ steps.nudge.outputs.public_url }}'
          {
            printf 'Run: %s (attempt %s)\n' "$SOURCE_RUN_ID" "$SOURCE_RUN_ATTEMPT"
            printf 'Event: %s\n' "$SOURCE_EVENT"
            printf 'Branch: %s\n' "$branch"
            printf 'Head SHA: %s\n' "$SOURCE_HEAD_SHA"
            if [ -n "$run_url" ] && [ "$run_url" != 'null' ]; then
              printf 'Run URL: %s\n' "$run_url"
            fi
            if [ -n "$diag_url" ]; then
              printf 'Diagnostics: %s\n' "$diag_url"
            else
              printf 'Diagnostics: (not published)\n'
            fi
            printf 'Run logs: https://api.github.com/repos/${{ github.repository }}/actions/runs/%s/logs\n' "$SOURCE_RUN_ID"
            printf 'Repository zip: https://api.github.com/repos/${{ github.repository }}/zipball/%s\n' "$SOURCE_HEAD_SHA"
            printf '\nArtifacts:\n'
          } > "$dest/codex_nudge.txt"
          if [ -f upstream_artifacts.json ]; then
            jq -r '.artifacts[] | "- " + (.name // "(no-name)") + " -> " + (.url // "(no-url)")' upstream_artifacts.json >> "$dest/codex_nudge.txt"
          else
            echo '- (artifact metadata unavailable)' >> "$dest/codex_nudge.txt"
          fi
          if [ -n "$diag_url" ]; then
            printf '%s\n' "$diag_url" > "$dest/codex_nudge_url.txt"
          fi

      - name: Check for API key
        id: keycheck
        run: |
          if [ -z "${{ secrets.OPENAI_API_KEY }}" ]; then
            echo "present=false" >> "$GITHUB_OUTPUT"
            {
              echo '- OPENAI_API_KEY: missing'
              echo '- iteration: skipped (no key)'
            } >> "$GITHUB_STEP_SUMMARY"
          else
            echo "present=true" >> "$GITHUB_OUTPUT"
            echo '- OPENAI_API_KEY: present' >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Mini preflight (chat.completions)
        id: preflight
        if: ${{ steps.keycheck.outputs.present == 'true' }}
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          work="$RUNNER_TEMP/preflight"
          mkdir -p "$work"
          cat <<'JSON' > "$work/request.json"
          {
            "model": "gpt-4o-mini",
            "messages": [
              {"role": "system", "content": [{"type": "text", "text": "Respond with a single token."}]},
              {"role": "user", "content": [{"type": "text", "text": "ping"}]}
            ],
            "max_tokens": 1
          }
          JSON
          http_code=$(curl -sS -o "$work/response.json" -w "%{http_code}" \
            https://api.openai.com/v1/chat/completions \
            -H "authorization: Bearer $OPENAI_API_KEY" \
            -H "content-type: application/json" \
            -d @"$work/request.json" || true)
          printf 'http_code=%s\n' "$http_code" >> "$GITHUB_OUTPUT"
          if [ "$http_code" = "200" ]; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
            echo 'mini-ok (chat.completions 200)' >> "$GITHUB_STEP_SUMMARY"
          else
            echo "ok=false" >> "$GITHUB_OUTPUT"
            echo "::warning title=mini preflight failed::HTTP $http_code from chat.completions" >> "$GITHUB_STEP_SUMMARY"
          fi
          cp "$work/response.json" preflight_response.json

      - name: Install Codex CLI
        if: ${{ steps.preflight.outputs.ok == 'true' && steps.ctx.outputs.can_push == 'true' }}
        run: |
          npm install -g @openai/codex@0.46.0

      - name: Build Codex prompt
        if: ${{ steps.preflight.outputs.ok == 'true' && steps.ctx.outputs.can_push == 'true' }}
        run: |
          set -euo pipefail
          cat <<'MARKDOWN' > codex_prompt.md
          You are the Codex CI assistant. A previous GitHub Actions run failed and we need a minimal fix.

          Repository: ${{ github.repository }}
          Head branch: ${{ steps.ctx.outputs.branch }}
          Head SHA: ${SOURCE_HEAD_SHA}
          Upstream run: ${SOURCE_RUN_ID} (attempt ${SOURCE_RUN_ATTEMPT})
          Run event: ${SOURCE_EVENT}
          Run URL: ${{ steps.ctx.outputs.run_url || '(not available)' }}
          Diagnostics: ${{ steps.nudge.outputs.public_url || '(not published yet)' }}
          Run logs API: https://api.github.com/repos/${{ github.repository }}/actions/runs/${SOURCE_RUN_ID}/logs
          Repository zip: https://api.github.com/repos/${{ github.repository }}/zipball/${SOURCE_HEAD_SHA}

          Artifacts from the failing run:
          MARKDOWN
          if [ -f upstream_artifacts.json ]; then
            jq -r '.artifacts[] | "- " + (.name // "(no-name)") + " (" + (.size_in_bytes|tostring) + " bytes) â†’ " + (.url // "(no-url)")' upstream_artifacts.json >> codex_prompt.md
          else
            echo '- (artifact metadata unavailable)' >> codex_prompt.md
          fi
          cat <<'MARKDOWN' >> codex_prompt.md
          Guidance:
          - Investigate the diagnostics and reproduce locally when possible.
          - Make the smallest change that fixes the failure while keeping tests intact.
          - Do not rewrite history; create commits on top of the checked-out branch.
          - Use the provided environment (Windows bootstrapper focus) and honor repo policies.
          - After applying fixes, stage and commit using `git commit` with a clear message.
          MARKDOWN
          cp codex_prompt.md "$RUNNER_TEMP/codex_prompt.md"

      - name: Run Codex attempts (max 4)
        id: attempts
        if: ${{ steps.preflight.outputs.ok == 'true' && steps.ctx.outputs.can_push == 'true' }}
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          BRANCH_NAME: ${{ steps.ctx.outputs.branch }}
        run: |
          set -euo pipefail
          log="$RUNNER_TEMP/codex_exec.log"
          prompt="$RUNNER_TEMP/codex_prompt.md"
          : > "$log"
          commit_pushed='false'
          attempts_run=0
          for attempt in 1 2 3 4; do
            attempts_run=$attempt
            echo "=== Attempt $attempt ($(date -u +%FT%TZ)) ===" | tee -a "$log"
            git reset --hard "$SOURCE_HEAD_SHA" >> "$log" 2>&1
            git clean -fdx >> "$log" 2>&1
            git checkout -B "$BRANCH_NAME" "$SOURCE_HEAD_SHA" >> "$log" 2>&1
            unset status
            codex exec \
              --model "$CODEX_MODEL" \
              --sandbox workspace-write \
              --full-auto \
              --output-last-message "$RUNNER_TEMP/codex_last.json" \
              - < "$prompt" >> "$log" 2>&1 || status=$?
            status=${status:-0}
            echo "codex exit: $status" | tee -a "$log"
            if git status --porcelain | grep -q '.'; then
              echo "changes-detected" | tee -a "$log"
              git add -A >> "$log" 2>&1
              git commit -m "codex: auto-iterate attempt $attempt" >> "$log" 2>&1 || true
              git push origin "$BRANCH_NAME" >> "$log" 2>&1 || true
              commit_pushed='true'
              break
            else
              echo "no changes from attempt $attempt" | tee -a "$log"
            fi
          done
          echo "attempts=$attempts_run" >> "$GITHUB_OUTPUT"
          echo "commit_pushed=$commit_pushed" >> "$GITHUB_OUTPUT"
          echo "log_path=$log" >> "$GITHUB_OUTPUT"
          if [ "$commit_pushed" != 'true' ]; then
            echo "::warning title=Codex iterate::No commit produced after $attempts_run attempt(s)" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "- commit pushed after attempt $attempts_run" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Note skipped iteration path
        if: ${{ steps.keycheck.outputs.present != 'true' || steps.preflight.outputs.ok != 'true' || steps.ctx.outputs.can_push != 'true' }}
        run: |
          echo "- iteration skipped: key=${{ steps.keycheck.outputs.present || 'false' }}, preflight=${{ steps.preflight.outputs.ok || 'false' }}, pushable=${{ steps.ctx.outputs.can_push }}" >> "$GITHUB_STEP_SUMMARY"

      - name: Upload nudge bundle
        uses: actions/upload-artifact@v4
        with:
          name: codex-nudge-${{ github.run_id }}-${{ github.run_attempt }}
          path: ${{ runner.temp }}/nudge
          if-no-files-found: ignore
          retention-days: 7

      - name: Upload preflight log
        uses: actions/upload-artifact@v4
        with:
          name: codex-preflight-${{ github.run_id }}-${{ github.run_attempt }}
          path: |
            preflight_response.json
            upstream_artifacts.json
            ${{ runner.temp }}/codex_prompt.md
          if-no-files-found: ignore
          retention-days: 7

      - name: Upload Codex execution log
        if: ${{ steps.attempts.outputs.log_path != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: iterate-diag-${{ github.run_id }}-${{ github.run_attempt }}
          path: |
            ${{ steps.attempts.outputs.log_path }}
            ${{ runner.temp }}/codex_prompt.md
            ${{ runner.temp }}/nudge
          if-no-files-found: ignore
          retention-days: 14

      - name: Collect diagnostics bundle path
        id: diag_bundle
        run: |
          set -euo pipefail
          dir="$RUNNER_TEMP/iterate-diag"
          mkdir -p "$dir"
          if [ -n "${{ steps.attempts.outputs.log_path }}" ] && [ -f "${{ steps.attempts.outputs.log_path }}" ]; then
            cp "${{ steps.attempts.outputs.log_path }}" "$dir/"
          fi
          if [ -f "$RUNNER_TEMP/codex_prompt.md" ]; then
            cp "$RUNNER_TEMP/codex_prompt.md" "$dir/"
          fi
          if [ -f preflight_response.json ]; then
            cp preflight_response.json "$dir/"
          fi
          if [ -f upstream_artifacts.json ]; then
            cp upstream_artifacts.json "$dir/"
          fi
          if [ -d "$RUNNER_TEMP/nudge" ]; then
            cp -R "$RUNNER_TEMP/nudge" "$dir/"
          fi
          printf 'dir=%s\n' "$dir" >> "$GITHUB_OUTPUT"
          if [ -f "$dir/codex_exec.log" ]; then
            tail -n 40 "$dir/codex_exec.log" > "$dir/codex_exec.tail.txt"
            printf 'manifest=%s\n' "$dir/codex_exec.tail.txt" >> "$GITHUB_OUTPUT"
          fi

  deploy-iterate-pages:
    name: Deploy iterate diagnostics to Pages
    needs: iterate
    if: ${{ always() }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      pages: write
      id-token: write
    environment:
      name: github-pages
    env:
      SOURCE_RUN_ID: ${{ github.event.workflow_run.id }}
      SOURCE_RUN_ATTEMPT: ${{ github.event.workflow_run.run_attempt }}
    steps:
      - name: Download iterate diagnostics
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: iterate-diag-${{ github.run_id }}-${{ github.run_attempt }}
          path: ${{ runner.temp }}/iterate-diag

      - name: Stage diagnostics
        run: |
          set -euo pipefail
          rm -rf public
          mkdir -p public/logs
          src="${RUNNER_TEMP}/iterate-diag"
          if [ -d "$src" ]; then
            cp -R "$src"/* public/logs/ || true
          fi
          touch public/.nojekyll
          repo='${{ github.repository }}'
          tail_file=''
          tail_text=''
          if [ -f "$src/codex_exec.log" ]; then
            tail_file="$src/codex_exec.log"
          elif [ -d "$src" ]; then
            tail_file=$(find "$src" -type f -name 'codex_exec.log' -print -quit)
          fi
          if [ -n "$tail_file" ] && [ -f "$tail_file" ]; then
            tail_text=$(tail -n 40 "$tail_file" 2>/dev/null)
          fi
          index_md=public/index.md
          {
            echo '# Codex iterate diagnostics'
            echo ''
            echo "- Repo: $repo"
            echo "- Upstream run: ${SOURCE_RUN_ID} (attempt ${SOURCE_RUN_ATTEMPT})"
            echo "- Preflight ok: ${{ needs.iterate.outputs.preflight_ok }}"
            echo "- Commit pushed: ${{ needs.iterate.outputs.commit_pushed }}"
            echo ''
            echo '## Artifacts'
          } > "$index_md"
          if ls public/logs 1>/dev/null 2>&1; then
            find public/logs -type f | sort | sed 's#^public/##' | while read -r f; do
              printf ' - [%s](%s)\n' "$f" "$f" >> "$index_md"
            done
          else
            echo '- (no logs captured)' >> "$index_md"
          fi
          {
            echo ''
            echo '## Codex log tail'
            echo '```text'
            if [ -n "$tail_text" ]; then
              printf '%s\n' "$tail_text"
            else
              echo '(log tail unavailable)'
            fi
            echo '```'
          } >> "$index_md"
          cat <<'HTML' > public/index.html
          <!doctype html>
          <meta charset="utf-8">
          <title>Codex iterate diagnostics</title>
          <style>
          body{font-family:ui-sans-serif,system-ui;margin:24px;line-height:1.5}
          code,pre{font-family:ui-monospace,Consolas,monospace}
          a{color:#0366d6}
          </style>
          <h1>Codex iterate diagnostics</h1>
          <p><strong>Repo:</strong> ${repo}<br>
          <strong>Upstream run:</strong> ${SOURCE_RUN_ID} (attempt ${SOURCE_RUN_ATTEMPT})<br>
          <strong>Preflight ok:</strong> ${{ needs.iterate.outputs.preflight_ok }}<br>
          <strong>Commit pushed:</strong> ${{ needs.iterate.outputs.commit_pushed }}</p>
          <p>See <a href="index.md">index.md</a> for the Markdown listing.</p>
          HTML

      - uses: actions/configure-pages@v4

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          name: pages-iterate-${{ github.run_id }}-${{ github.run_attempt }}
          path: public

      - name: Deploy to Pages
        id: deploy
        uses: actions/deploy-pages@v4

      - name: Record deployed URL
        if: ${{ steps.deploy.outputs.page_url != '' }}
        run: |
          url='${{ steps.deploy.outputs.page_url }}'
          {
            echo '### Codex iterate diagnostics'
            echo "- Pages URL: [$url]($url)"
          } >> "$GITHUB_STEP_SUMMARY"
