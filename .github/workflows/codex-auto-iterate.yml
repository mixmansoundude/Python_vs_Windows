# =============================================================================
# Codex – Auto Iterate on CI Failure
# version: v2025-10-07.19c   # minimal patch: allow cancelled/timed_out
#
# Purpose:
#   Trigger ONLY when the Windows "Batch syntax/run check" workflow completes,
#   and run when its conclusion is failure/cancelled/timed_out; then launch a
#   headless Codex pass to propose/apply minimal changes and open/update a PR.
#
# Notes:
#   - If OPENAI_API_KEY is missing, it cleanly no-ops with an obvious summary.
#   - Temp files live ONLY in $RUNNER_TEMP (never committed).
#   - Codex runs with:  workspace-write  +  approval: never (unattended CI).
# =============================================================================

name: Codex – Auto Iterate on CI Failure

on:
  # Fire after our Windows workflow finishes.
  workflow_run:
    workflows: ["Batch syntax/run check"]   # exact name
    types: [completed]
  # Allow a manual dry-run/smoke without waiting for a failure.
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

# Keep iterations for the same branch serialized, but do NOT cancel in-progress runs.
concurrency:
  group: codex-iterate-${{ github.event.workflow_run.head_branch || github.ref_name }}
  cancel-in-progress: false

env:
  ITERATOR_VERSION: v2025-10-07.19c
  OPENAI_MODEL: gpt-4o-mini
  MAX_ATTEMPTS: "20"           # guardrail: stop after N codex commits overall

jobs:
  iterate:
    # v19 -> v19c change: include 'cancelled' and 'timed_out' so we still iterate
    # when the upstream workflow is marked cancelled even if a job failed.
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && contains(fromJson('["failure","cancelled","timed_out"]'), github.event.workflow_run.conclusion)) }}
    runs-on: ubuntu-latest

    steps:
      - name: Iterator version
        run: |
          echo "### Codex iterator" >> "$GITHUB_STEP_SUMMARY"
          echo "- version: $ITERATOR_VERSION" >> "$GITHUB_STEP_SUMMARY"

      - name: Checkout failing branch
        uses: actions/checkout@v4
        with:
          # On workflow_run we target the same branch that failed
          ref: ${{ github.event.workflow_run.head_branch || github.ref_name }}
          fetch-depth: 0

      - name: Normalize CRLF (harmless no-op on Linux files)
        run: |
          git config core.autocrlf true
          git config core.eol crlf

      # Detect whether OPENAI_API_KEY is present WITHOUT leaking it.
      - name: Check for OPENAI_API_KEY
        id: apikey
        shell: bash
        run: |
          if [ -n "${{ secrets.OPENAI_API_KEY }}" ]; then
            echo "present=true" >> "$GITHUB_OUTPUT"
          else
            echo "present=false" >> "$GITHUB_OUTPUT"
          fi

      # Download artifacts emitted by the failed Windows run (if any).
      - name: Download codex_nudge.txt (if present)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          run_id: ${{ github.event.workflow_run.id }}
          name: codex_nudge.txt
          path: ${{ runner.temp }}

      - name: Download CI summary (if present)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          run_id: ${{ github.event.workflow_run.id }}
          name: ci_test_summary.txt
          path: ${{ runner.temp }}

      - name: Download CI NDJSON (if present)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          run_id: ${{ github.event.workflow_run.id }}
          name: ci_test_results.ndjson
          path: ${{ runner.temp }}

      # Loud but clean skip when no API key
      - name: Skip (no OPENAI_API_KEY configured)
        if: steps.apikey.outputs.present != 'true'
        shell: bash
        run: |
          echo "::notice title=Codex auto-iterate is disabled::Reason: OPENAI_API_KEY not set. Skipping headless iteration and leaving existing flow unchanged."
          {
            echo "#### Auto-iterate skipped"
            echo ""
            echo "- Reason: \`OPENAI_API_KEY\` is not configured in repo **Settings → Secrets and variables → Actions**."
            echo "- Effect: No headless Codex run; your existing behavior (manual flow) remains unchanged."
            echo "- Iterator version: $ITERATOR_VERSION"
          } >> "$GITHUB_STEP_SUMMARY"
          printf "Codex auto-iterate skipped: missing OPENAI_API_KEY\n" > "$RUNNER_TEMP/codex_skip_reason.txt"

      - name: Upload skip reason
        if: steps.apikey.outputs.present != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: codex-skip-reason
          path: ${{ runner.temp }}/codex_skip_reason.txt
          retention-days: 7

      # Only proceed if we have an API key
      - name: Install Codex CLI
        if: steps.apikey.outputs.present == 'true'
        run: npm i -g @openai/codex@latest

      - name: Git author (bot)
        if: steps.apikey.outputs.present == 'true'
        run: |
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name  "github-actions[bot]"

      # Global attempt guard across the history (count commits with our prefix)
      - name: Loop guard
        if: steps.apikey.outputs.present == 'true'
        id: guard
        shell: bash
        run: |
          COUNT=$(git rev-list --all --grep='^codex: iterate on CI failure' | wc -l || true)
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"
          if [ "$COUNT" -ge "$MAX_ATTEMPTS" ]; then
            echo "stop=true" >> "$GITHUB_OUTPUT"
            echo "Reached $MAX_ATTEMPTS attempts; exiting without changes." >> "$GITHUB_STEP_SUMMARY"
          else
            echo "stop=false" >> "$GITHUB_OUTPUT"
            echo "next=$((COUNT+1))" >> "$GITHUB_OUTPUT"
          fi

      - name: Build prompt for Codex
        if: steps.apikey.outputs.present == 'true' && steps.guard.outputs.stop == 'false'
        id: prompt
        shell: bash
        run: |
          set -euo pipefail
          PROMPT="$RUNNER_TEMP/prompt.txt"

          # Seed with the nudge if present; otherwise a generic brief.
          if [ -f "$RUNNER_TEMP/codex_nudge.txt/codex_nudge.txt" ]; then
            BASE="$(cat "$RUNNER_TEMP/codex_nudge.txt/codex_nudge.txt")"
          else
            BASE="Analyze the last CI failure and apply the smallest safe change set to make our Windows CI pass."
          fi

          {
            printf "%s\n\n" "$BASE"
            echo "Constraints:"
            echo "- Preserve CRLF; ASCII where practical; keep Windows batch scripts robust."
            echo "- Avoid sweeping refactors; make minimal, targeted edits."
            echo "- Update matching tests/docs when behavior is intentional and gates assert it."
            echo "- Produce actual file edits in the workspace."
            # Append compact slices of CI outputs if present (best-effort).
            if [ -f "$RUNNER_TEMP/ci_test_summary.txt/ci_test_summary.txt" ]; then
              echo ""
              echo "----- CI Summary (first 300 lines) -----"
              head -n 300 "$RUNNER_TEMP/ci_test_summary.txt/ci_test_summary.txt"
            fi
            if [ -f "$RUNNER_TEMP/ci_test_results.ndjson/ci_test-results.ndjson" ]; then
              echo ""
              echo "----- CI NDJSON (first 40 lines) -----"
              head -n 40 "$RUNNER_TEMP/ci_test_results.ndjson/ci_test-results.ndjson"
            fi
          } > "$PROMPT"

          echo "path=$PROMPT" >> "$GITHUB_OUTPUT"
          {
            echo ""
            echo "#### Prompt (head)"
            echo '```'
            head -n 60 "$PROMPT"
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

      # Write-enabled + no-approval; retry briefly on transient stream errors.
      - name: Run Codex headlessly (write-enabled, resilient)
        if: steps.apikey.outputs.present == 'true' && steps.guard.outputs.stop == 'false'
        id: codex
        timeout-minutes: 10
        continue-on-error: true
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: ${{ env.OPENAI_MODEL }}
        shell: bash
        run: |
          set -o pipefail
          LOG="$RUNNER_TEMP/codex_exec.log"
          PROMPT_PATH="${{ steps.prompt.outputs.path }}"
          BRANCH="codex/ci-fix-${{ github.event.workflow_run.head_branch || github.ref_name }}"
          echo "Target branch: $BRANCH" | tee -a "$LOG"
          tries=0
          max=3
          until [ $tries -ge $max ]; do
            tries=$((tries+1))
            echo "=== Codex attempt $tries/$max (model=$OPENAI_MODEL) ===" | tee -a "$LOG"
            codex -a never --sandbox workspace-write exec --model "$OPENAI_MODEL" "$(cat "$PROMPT_PATH")" 2>&1 | tee -a "$LOG"
            rc=${PIPESTATUS[0]}
            if [ $rc -eq 0 ]; then
              echo "codex exec exit code 0" | tee -a "$LOG"
              break
            fi
            if grep -qi 'stream error' "$LOG"; then
              echo "Detected stream error. Sleeping briefly before retry..." | tee -a "$LOG"
              sleep 6
              continue
            fi
            echo "Non-stream failure (rc=$rc). Not retrying." | tee -a "$LOG"
            break
          done
          # Save branch name for later steps
          echo "BRANCH=$BRANCH" >> "$GITHUB_ENV"

      - name: Detect changes
        if: steps.apikey.outputs.present == 'true' && steps.guard.outputs.stop == 'false'
        id: diffcheck
        shell: bash
        run: |
          if [ -z "$(git status --porcelain)" ]; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
            # Save a diffstat for the summary
            (git diff --staged --stat=160,999 || git diff --stat=160,999) > "$RUNNER_TEMP/diffstat.txt" || true
          fi

      # Clean any accidental temp files that might have been written into the repo
      - name: Clean repo temp files
        if: steps.apikey.outputs.present == 'true' && steps.guard.outputs.stop == 'false'
        run: |
          rm -f prompt.txt codex_nudge.txt codex_exec.log || true

      # Let the action stage/commit/push internally (avoid the "no changes" trap).
      - name: Create/Update PR (commit & push inside action)
        if: steps.apikey.outputs.present == 'true' && steps.guard.outputs.stop == 'false' && steps.diffcheck.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token:  ${{ secrets.GITHUB_TOKEN }}
          base:   ${{ github.event.workflow_run.head_branch || github.ref_name }}
          branch: ${{ env.BRANCH }}
          title:  "Codex: iterate on CI failure – ${{ github.event.workflow_run.head_branch || github.ref_name }}"
          body:   "Automated Codex iteration.\n\n- Iterator version: ${{ env.ITERATOR_VERSION }}\n- Model: ${{ env.OPENAI_MODEL }}\n- Minimal edits; CRLF/Windows-safe."
          labels: codex,ci-fix,automerge-candidate
          commit-message: "codex: iterate on CI failure (attempt ${{ steps.guard.outputs.next }}/${{ env.MAX_ATTEMPTS }}) for ${{ github.event.workflow_run.head_branch || github.ref_name }}"

      # Always upload logs & prompt so we can debug even when nothing changed.
      - name: Upload Codex artifacts (always)
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: codex-iterate-${{ github.run_id }}-${{ github.run_attempt }}
          path: |
            ${{ runner.temp }}/codex_exec.log
            ${{ steps.prompt.outputs.path }}
          if-no-files-found: warn
          retention-days: 14

      - name: Summarize Codex outcome
        if: ${{ always() }}
        shell: bash
        run: |
          echo "### Codex iterate summary" >> "$GITHUB_STEP_SUMMARY"
          echo "- iterator version: $ITERATOR_VERSION" >> "$GITHUB_STEP_SUMMARY"
          echo "- model: $OPENAI_MODEL" >> "$GITHUB_STEP_SUMMARY"
          echo "- branch: ${{ env.BRANCH || github.event.workflow_run.head_branch || github.ref_name }}" >> "$GITHUB_STEP_SUMMARY"
          if [ "${{ steps.diffcheck.outputs.changed || 'false' }}" = "true" ]; then
            echo "- result: changes detected (PR will be created/updated)" >> "$GITHUB_STEP_SUMMARY"
            if [ -f "$RUNNER_TEMP/diffstat.txt" ]; then
              echo "" >> "$GITHUB_STEP_SUMMARY"
              echo "#### Diffstat" >> "$GITHUB_STEP_SUMMARY"
              { echo '```'; cat "$RUNNER_TEMP/diffstat.txt"; echo '```'; } >> "$GITHUB_STEP_SUMMARY"
            fi
          else
            echo "- result: no changes produced" >> "$GITHUB_STEP_SUMMARY"
          fi
          if [ -f "$RUNNER_TEMP/codex_exec.log" ]; then
            if grep -qi 'stream error' "$RUNNER_TEMP/codex_exec.log"; then
              echo "- note: stream errors occurred; a short retry was attempted" >> "$GITHUB_STEP_SUMMARY"
            fi
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "#### codex_exec.log (tail)" >> "$GITHUB_STEP_SUMMARY"
            { echo '```'; tail -n 60 "$RUNNER_TEMP/codex_exec.log" | sed 's/\x1b\[[0-9;]*m//g'; echo '```'; } >> "$GITHUB_STEP_SUMMARY"
          fi
