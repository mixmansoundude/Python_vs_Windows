# yamllint disable rule:line-length rule:truthy
---
name: Codex - Auto Iterate on CI Failure

on:
  workflow_run:
    workflows:
      - Batch syntax/run check
    types:
      - completed

permissions:
  contents: write
  actions: read
  pages: write

jobs:
  iterate:
    name: Codex auto-iterate
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      MAX_ATTEMPTS: '4'
    steps:
      - name: Gather upstream run context
        id: upstream
        shell: bash
        run: |
          set -euo pipefail
          run_id="${{ github.event.workflow_run.id }}"
          run_attempt="${{ github.event.workflow_run.run_attempt }}"
          conclusion="${{ github.event.workflow_run.conclusion }}"
          head_branch="${{ github.event.workflow_run.head_branch }}"
          head_sha="${{ github.event.workflow_run.head_sha }}"
          run_html="${{ github.event.workflow_run.html_url }}"
          logs_url="${{ github.event.workflow_run.logs_url }}"
          workflow_name="${{ github.event.workflow_run.name }}"
          echo "run_id=$run_id" >> "$GITHUB_OUTPUT"
          echo "run_attempt=$run_attempt" >> "$GITHUB_OUTPUT"
          echo "conclusion=$conclusion" >> "$GITHUB_OUTPUT"
          echo "head_branch=$head_branch" >> "$GITHUB_OUTPUT"
          echo "head_sha=$head_sha" >> "$GITHUB_OUTPUT"
          echo "run_url=$run_html" >> "$GITHUB_OUTPUT"
          echo "logs_url=$logs_url" >> "$GITHUB_OUTPUT"
          echo "workflow_name=$workflow_name" >> "$GITHUB_OUTPUT"
          {
            echo "### Upstream workflow run"
            echo "- workflow: ${workflow_name:-unknown}"
            echo "- run: [$run_id](${run_html:-https://github.com/${{ github.repository }}/actions/runs/$run_id})"
            echo "- attempt: ${run_attempt:-1}"
            echo "- conclusion: ${conclusion:-unknown}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Prepare iteration workspace
        id: prepare
        shell: bash
        run: |
          set -euo pipefail
          ctx_dir="$RUNNER_TEMP/codex/${{ steps.upstream.outputs.run_id }}-${{ steps.upstream.outputs.run_attempt }}"
          mkdir -p "$ctx_dir"
          log_path="$RUNNER_TEMP/codex_exec.log"
          echo "context_dir=$ctx_dir" >> "$GITHUB_OUTPUT"
          echo "log_path=$log_path" >> "$GITHUB_OUTPUT"

      - name: Evaluate upstream result
        id: gate
        shell: bash
        run: |
          set -euo pipefail
          conclusion="${{ steps.upstream.outputs.conclusion }}"
          if [ "${conclusion,,}" = "success" ]; then
            echo "should_run=false" >> "$GITHUB_OUTPUT"
            {
              echo "### Iterate status"
              echo "- upstream conclusion: success"
              echo "- action: no iteration (nothing to do)"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            echo "should_run=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout failing revision
        if: ${{ steps.gate.outputs.should_run == 'true' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ steps.upstream.outputs.head_sha }}

      - name: Configure Git identity
        if: ${{ steps.gate.outputs.should_run == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Check OpenAI API key presence
        id: key
        if: ${{ steps.gate.outputs.should_run == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.OPENAI_API_KEY }}" ]; then
            echo "present=false" >> "$GITHUB_OUTPUT"
            echo "reason=no-key" >> "$GITHUB_OUTPUT"
            echo "- OPENAI_API_KEY: missing" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "present=true" >> "$GITHUB_OUTPUT"
            echo "reason=available" >> "$GITHUB_OUTPUT"
          fi

      - name: Mini preflight (gpt-4o-mini)
        id: preflight
        if: ${{ steps.gate.outputs.should_run == 'true' && steps.key.outputs.present == 'true' }}
        shell: bash
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          req="$RUNNER_TEMP/preflight_req.json"
          res="$RUNNER_TEMP/preflight_res.json"
          printf '%s\n' '{' \
            '  "model": "gpt-4o-mini",' \
            '  "messages": [' \
            '    {"role": "system", "content": "Codex CI preflight"},' \
            '    {"role": "user", "content": "ping"}' \
            '  ],' \
            '  "max_tokens": 1' \
            '}' > "$req"
          http=$(curl -sS -o "$res" -w "%{http_code}"             -H "Authorization: Bearer $OPENAI_API_KEY"             -H "Content-Type: application/json"             https://api.openai.com/v1/chat/completions             -d @"$req" || echo 000)
          echo "http_status=$http" >> "$GITHUB_OUTPUT"
          echo "response_path=$res" >> "$GITHUB_OUTPUT"
          if [ "$http" = "200" ]; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
          else
            echo "ok=false" >> "$GITHUB_OUTPUT"
          fi
          {
            echo "### Mini preflight"
            echo "- http_status: $http"
            echo "- ok: $([ "$http" = "200" ] && echo true || echo false)"
          } >> "$GITHUB_STEP_SUMMARY"
          if [ "$http" != "200" ]; then
            echo '```json' >> "$GITHUB_STEP_SUMMARY"
            head -c 400 "$res" | sed 's/[^[:print:]	]/?/g' >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Ensure Codex CLI available
        id: cli
        if: ${{ steps.gate.outputs.should_run == 'true' && steps.key.outputs.present == 'true' && steps.preflight.outputs.ok == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          available=false
          if command -v codex >/dev/null 2>&1; then
            available=true
          else
            if command -v npm >/dev/null 2>&1; then
              npm install -g @openai/codex-cli@latest >/dev/null 2>&1 || true
            fi
            if ! command -v codex >/dev/null 2>&1; then
              python3 -m pip install --user codex-cli >/dev/null 2>&1 ||               python3 -m pip install --user openai-codex-cli >/dev/null 2>&1 || true
              echo "$HOME/.local/bin" >> "$GITHUB_PATH"
            fi
            if command -v codex >/dev/null 2>&1; then
              available=true
            fi
          fi
          if [ "$available" = true ]; then
            codex --help >/dev/null 2>&1 || true
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo "::warning::Codex CLI unavailable after installation attempts; skipping iteration." >&2
          fi

      - name: Collect upstream artifacts
        id: artifacts
        if: ${{ steps.gate.outputs.should_run == 'true' }}
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          CONTEXT_DIR: ${{ steps.prepare.outputs.context_dir }}
          RUN_ID: ${{ steps.upstream.outputs.run_id }}
        run: |
          set -euo pipefail
          meta="$RUNNER_TEMP/upstream_artifacts.json"
          api="https://api.github.com/repos/${{ github.repository }}/actions/runs/${RUN_ID}/artifacts?per_page=100"
          curl -sSL -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" "$api" -o "$meta"
          list="$CONTEXT_DIR/artifacts.json"
          jq --arg run_id "$RUN_ID" '{run_id: $run_id, artifacts: [.artifacts[] | select(.expired==false) | {name, size_in_bytes, archive_download_url}]}' "$meta" > "$list"
          echo "meta_path=$meta" >> "$GITHUB_OUTPUT"
          echo "list_path=$list" >> "$GITHUB_OUTPUT"

      - name: Extract diagnostics URL (if published)
        id: diagurl
        if: ${{ steps.gate.outputs.should_run == 'true' }}
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          META_PATH: ${{ steps.artifacts.outputs.meta_path }}
          CONTEXT_DIR: ${{ steps.prepare.outputs.context_dir }}
        run: |
          set -euo pipefail
          if [ ! -f "$META_PATH" ]; then
            exit 0
          fi
          artifact_id=$(jq -r '.artifacts[] | select(.expired==false) | select(.name | test("codex_nudge_url")) | .id' "$META_PATH" | head -n 1)
          if [ -z "$artifact_id" ] || [ "$artifact_id" = "null" ]; then
            exit 0
          fi
          zipfile="$RUNNER_TEMP/codex_nudge_url.zip"
          curl -sSL -H "Authorization: Bearer $GH_TOKEN" -L "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/$artifact_id/zip" -o "$zipfile"
          mkdir -p "$CONTEXT_DIR/upstream"
          unzip -q "$zipfile" -d "$CONTEXT_DIR/upstream"
          url_file=$(find "$CONTEXT_DIR/upstream" -name 'codex_nudge_url.txt' -print -quit)
          if [ -n "$url_file" ] && [ -f "$url_file" ]; then
            diag=$(head -n 1 "$url_file")
            echo "url=$diag" >> "$GITHUB_OUTPUT"
          fi

      - name: Compose codex nudge files
        id: nudge
        if: ${{ steps.gate.outputs.should_run == 'true' }}
        shell: python
        env:
          CONTEXT_DIR: ${{ steps.prepare.outputs.context_dir }}
          ARTIFACTS_JSON: ${{ steps.artifacts.outputs.list_path }}
          RUN_URL: ${{ steps.upstream.outputs.run_url }}
          LOGS_URL: ${{ steps.upstream.outputs.logs_url }}
          REPO_SLUG: ${{ github.repository }}
          HEAD_SHA: ${{ steps.upstream.outputs.head_sha }}
          DIAG_URL: ${{ steps.diagurl.outputs.url }}
        run: |
          import json
          import os
          from pathlib import Path

          ctx = Path(os.environ['CONTEXT_DIR'])
          data_path = Path(os.environ['ARTIFACTS_JSON']) if os.environ.get('ARTIFACTS_JSON') else None
          artifacts = []
          if data_path and data_path.exists():
            artifacts = json.loads(data_path.read_text()).get('artifacts', [])

          urls = []
          def add(url: str):
            if url and url not in urls:
              urls.append(url)

          add(os.environ.get('DIAG_URL'))
          add(os.environ.get('RUN_URL'))
          add(os.environ.get('LOGS_URL'))
          repo_zip = f"https://api.github.com/repos/{os.environ['REPO_SLUG']}/zipball/{os.environ['HEAD_SHA']}"
          add(repo_zip)
          for item in artifacts:
            add(item.get('archive_download_url'))

          url_file = ctx / 'codex_nudge_url.txt'
          url_file.write_text('\\n'.join(urls) + ('\\n' if urls else ''))

          note_lines = [
            f"Run: {os.environ.get('RUN_URL', 'n/a')}",
            f"Logs: {os.environ.get('LOGS_URL', 'n/a')}",
            f"Repo zip: {repo_zip}",
            f"Diagnostics page: {os.environ.get('DIAG_URL', 'n/a')}",
            "",
            "Artifacts:",
          ]
          for item in artifacts:
            note_lines.append(f"- {item.get('name')}: {item.get('archive_download_url')}")

          (ctx / 'codex_nudge.txt').write_text('\\n'.join(note_lines) + '\\n')

      - name: Run Codex iterations
        id: codex_exec
        if: ${{ steps.gate.outputs.should_run == 'true' && steps.key.outputs.present == 'true' && steps.preflight.outputs.ok == 'true' && steps.cli.outputs.available == 'true' }}
        shell: bash
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          CONTEXT_DIR: ${{ steps.prepare.outputs.context_dir }}
          LOG_PATH: ${{ steps.prepare.outputs.log_path }}
          MAX_ATTEMPTS: ${{ env.MAX_ATTEMPTS }}
        run: |
          set -euo pipefail
          log="$LOG_PATH"
          : > "$log"
          attempt_log="$CONTEXT_DIR/codex_attempts.jsonl"
          : > "$attempt_log"
          attempts=0
          commit_created=0
          prev_head=$(git rev-parse HEAD)
          while [ $attempts -lt "$MAX_ATTEMPTS" ]; do
            attempts=$((attempts+1))
            echo "--- Attempt $attempts ---" | tee -a "$log"
            status=0
            if codex exec --model codex-gpt-5 --sandbox workspace-write exec >> "$log" 2>&1; then
              status=0
            else
              status=$?
            fi
            printf '{"attempt":%s,"exit_code":%s}\n' "$attempts" "$status" >> "$attempt_log"
            new_head=$(git rev-parse HEAD)
            if [ "$new_head" != "$prev_head" ]; then
              commit_created=1
              prev_head="$new_head"
              break
            fi
            if ! git diff --quiet; then
              printf '{"attempt":%s,"exit_code":%s,"note":"working tree dirty"}\n' "$attempts" "$status" >> "$attempt_log"
            fi
          done
          echo "attempts=$attempts" >> "$GITHUB_OUTPUT"
          echo "commit_created=$([ $commit_created -eq 1 ] && echo true || echo false)" >> "$GITHUB_OUTPUT"
          echo "attempt_log=$attempt_log" >> "$GITHUB_OUTPUT"
          echo "log_path=$log" >> "$GITHUB_OUTPUT"
          cp "$log" "$CONTEXT_DIR/codex_exec.log"

      - name: Upload iteration context artifact
        if: ${{ steps.gate.outputs.should_run == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: codex-context-${{ steps.upstream.outputs.run_id }}-${{ steps.upstream.outputs.run_attempt }}
          path: ${{ steps.prepare.outputs.context_dir }}
          if-no-files-found: ignore
          retention-days: 7

      - name: Summarize iteration result
        id: iterate_summary
        if: ${{ always() }}
        shell: bash
        env:
          SHOULD_RUN: ${{ steps.gate.outputs.should_run }}
          KEY_PRESENT: ${{ steps.key.outputs.present }}
          PREFLIGHT_OK: ${{ steps.preflight.outputs.ok }}
          PREFLIGHT_STATUS: ${{ steps.preflight.outputs.http_status }}
          CLI_AVAILABLE: ${{ steps.cli.outputs.available }}
          ATTEMPTS: ${{ steps.codex_exec.outputs.attempts }}
          COMMIT_CREATED: ${{ steps.codex_exec.outputs.commit_created }}
          LOG_PATH: ${{ steps.prepare.outputs.log_path }}
          CONTEXT_DIR: ${{ steps.prepare.outputs.context_dir }}
          PREFLIGHT_RESP: ${{ steps.preflight.outputs.response_path }}
        run: |
          set -euo pipefail
          note=""
          if [ "${SHOULD_RUN:-false}" != "true" ]; then
            note="Upstream run succeeded; iteration not required."
          elif [ "${KEY_PRESENT:-false}" != "true" ]; then
            note="Skipped: OPENAI_API_KEY missing."
          elif [ "${PREFLIGHT_OK:-false}" != "true" ]; then
            note="Skipped: mini preflight failed (HTTP ${PREFLIGHT_STATUS:-n/a})."
          elif [ "${CLI_AVAILABLE:-false}" != "true" ]; then
            note="Skipped: Codex CLI unavailable."
          elif [ -z "${ATTEMPTS:-}" ]; then
            note="Iteration prerequisites not met; no attempts executed."
          else
            note="Attempts executed: ${ATTEMPTS:-0}. Commit created: ${COMMIT_CREATED:-false}."
          fi
          if [ ! -f "$LOG_PATH" ]; then
            echo "$note" > "$LOG_PATH"
          elif [ ! -s "$LOG_PATH" ]; then
            echo "$note" >> "$LOG_PATH"
          fi
          if [ -n "$PREFLIGHT_RESP" ] && [ -f "$PREFLIGHT_RESP" ]; then
            cp "$PREFLIGHT_RESP" "$CONTEXT_DIR/preflight_response.json"
          fi
          {
            echo "### Codex iteration status"
            echo "- should_run: ${SHOULD_RUN:-false}"
            echo "- api_key_present: ${KEY_PRESENT:-false}"
            echo "- preflight_ok: ${PREFLIGHT_OK:-false}"
            echo "- cli_available: ${CLI_AVAILABLE:-false}"
            echo "- attempts: ${ATTEMPTS:-0}"
            echo "- commit_created: ${COMMIT_CREATED:-false}"
            echo "- note: $note"
          } >> "$GITHUB_STEP_SUMMARY"
          echo "status_note=$note" >> "$GITHUB_OUTPUT"

      - name: Build diagnostics page
        id: diag
        if: ${{ always() }}
        shell: python
        env:
          PUBLIC_DIR: ${{ runner.temp }}/codex-public
          CONTEXT_DIR: ${{ steps.prepare.outputs.context_dir }}
          LOG_PATH: ${{ steps.prepare.outputs.log_path }}
          STATUS_NOTE: ${{ steps.iterate_summary.outputs.status_note }}
          SHOULD_RUN: ${{ steps.gate.outputs.should_run }}
          PREFLIGHT_OK: ${{ steps.preflight.outputs.ok }}
          PREFLIGHT_STATUS: ${{ steps.preflight.outputs.http_status }}
          KEY_PRESENT: ${{ steps.key.outputs.present }}
          CLI_AVAILABLE: ${{ steps.cli.outputs.available }}
          ATTEMPTS: ${{ steps.codex_exec.outputs.attempts }}
          COMMIT_CREATED: ${{ steps.codex_exec.outputs.commit_created }}
          RUN_ID: ${{ steps.upstream.outputs.run_id }}
          RUN_ATTEMPT: ${{ steps.upstream.outputs.run_attempt }}
          RUN_URL: ${{ steps.upstream.outputs.run_url }}
          CONCLUSION: ${{ steps.upstream.outputs.conclusion }}
          HEAD_BRANCH: ${{ steps.upstream.outputs.head_branch }}
          HEAD_SHA: ${{ steps.upstream.outputs.head_sha }}
        run: |
          import json
          import os
          import shutil
          from pathlib import Path

          pub = Path(os.environ['PUBLIC_DIR'])
          ctx = Path(os.environ['CONTEXT_DIR'])
          pub.mkdir(parents=True, exist_ok=True)
          context_copy = pub / 'context'
          if ctx.exists():
            shutil.copytree(ctx, context_copy, dirs_exist_ok=True)

          log_path = Path(os.environ['LOG_PATH'])
          tail_lines = 20
          if log_path.exists():
            lines = log_path.read_text().splitlines()
            tail = '\n'.join(lines[-tail_lines:])
          else:
            tail = 'codex_exec.log not available.'

          event = json.loads(Path(os.environ['GITHUB_EVENT_PATH']).read_text())
          prs = [pr.get('number') for pr in event.get('workflow_run', {}).get('pull_requests', []) if isinstance(pr, dict) and 'number' in pr]
          pr_line = ', '.join(f"#{num}" for num in prs) if prs else 'none'

          md_lines = [
            '# Codex iteration diagnostics',
            '',
            f"* Repo: {os.environ['GITHUB_REPOSITORY']}",
            f"* Upstream run: [{os.environ['RUN_ID']}]({os.environ.get('RUN_URL', 'n/a')}) (attempt {os.environ.get('RUN_ATTEMPT', 'n/a')}, conclusion: {os.environ.get('CONCLUSION', 'n/a')})",
            f"* Head branch: {os.environ.get('HEAD_BRANCH', 'n/a')}",
            f"* Head SHA: `{os.environ.get('HEAD_SHA', 'n/a')}`",
            f"* Pull requests: {pr_line}",
            '',
            '## Status',
            f"- should_run: {os.environ.get('SHOULD_RUN', 'false')}",
            f"- api_key_present: {os.environ.get('KEY_PRESENT', 'false')}",
            f"- preflight_ok: {os.environ.get('PREFLIGHT_OK', 'false')} (HTTP {os.environ.get('PREFLIGHT_STATUS', 'n/a')})",
            f"- cli_available: {os.environ.get('CLI_AVAILABLE', 'false')}",
            f"- attempts: {os.environ.get('ATTEMPTS', '0')}",
            f"- commit_created: {os.environ.get('COMMIT_CREATED', 'false')}",
            f"- note: {os.environ.get('STATUS_NOTE', '')}",
            '',
            '## Codex exec log (tail)',
            '```text',
            tail or '<empty>',
            '```',
            '',
            '## Context files',
          ]

          for path in sorted(context_copy.rglob('*')):
            if path.is_file():
              rel = path.relative_to(pub)
              md_lines.append(f"- [{rel.as_posix()}]({rel.as_posix()})")

          (pub / 'index.md').write_text('\n'.join(md_lines) + '\n')

          html = [
            '<!doctype html>',
            '<meta charset="utf-8">',
            f"<title>Codex iterate diagnostics â€” run {os.environ.get('RUN_ID')}</title>",
            '<style>body{font-family:ui-sans-serif,system-ui;margin:24px;max-width:960px;}pre{background:#f6f8fa;padding:12px;}code{font-family:ui-monospace,Consolas,monospace;}</style>',
            '<h1>Codex iteration diagnostics</h1>',
            f"<p><strong>Repo:</strong> {os.environ['GITHUB_REPOSITORY']}<br><strong>Upstream run:</strong> <a href="{os.environ.get('RUN_URL', '#')}">{os.environ.get('RUN_ID')}</a> (attempt {os.environ.get('RUN_ATTEMPT', 'n/a')}, conclusion: {os.environ.get('CONCLUSION', 'n/a')})</p>",
            '<p>See <a href="index.md">index.md</a> for the Markdown report.</p>',
          ]
          (pub / 'index.html').write_text('\n'.join(html) + '\n')

          print(f"public_dir={pub}")

      - name: Upload diagnostics artifact
        uses: actions/upload-artifact@v4
        with:
          name: iterate-diag-${{ steps.upstream.outputs.run_id }}-${{ steps.upstream.outputs.run_attempt }}
          path: ${{ steps.diag.outputs.public_dir }}
          if-no-files-found: ignore
          retention-days: 7

      - uses: actions/configure-pages@v4

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          name: iterate-pages-${{ steps.upstream.outputs.run_id }}-${{ steps.upstream.outputs.run_attempt }}
          path: ${{ steps.diag.outputs.public_dir }}

  deploy:
    name: Deploy iterate diagnostics to Pages
    needs: iterate
    if: ${{ always() }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      pages: write
      id-token: write
    environment:
      name: github-pages
    steps:
      - name: Deploy
        id: deployment
        uses: actions/deploy-pages@v4
      - name: Pages URL
        if: ${{ steps.deployment.outputs.page_url != '' }}
        run: |
          echo "### Codex iterate diagnostics" >> "$GITHUB_STEP_SUMMARY"
          echo "${{ steps.deployment.outputs.page_url }}" >> "$GITHUB_STEP_SUMMARY"
