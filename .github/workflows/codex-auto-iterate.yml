# yamllint disable rule:line-length rule:truthy rule:colons rule:document-start
# version: v2025-10-06.9 (Cookbook-lean + Auth probe + API patcher + Push-poll main CI)
# Purpose: Iterate safely even when main CI can't start (YAML errors), by polling on push for head_sha runs.
# Notes:
# - On push: poll all workflow runs for this commit (head_sha). If none show up within timeout => iterate.
# - If a non-iterate workflow completes with conclusion != success => iterate. If success => skip.
# - On workflow_dispatch: iterate immediately.
# - You can keep `workflow_run` too, but push+poll already covers "main CI never started" scenarios.
# - Auth probe uses file-based JSON to avoid request-quoting issues.
# - Avoids status functions in expressions; uses small, robust conditions.
# - PR body only built when iterating to avoid empty sections.
# Helpful docs:
# - List runs for repo (head_sha): https://docs.github.com/rest/actions/workflow-runs#list-workflow-runs-for-a-repository
# - GitHub expressions: https://docs.github.com/actions/learn-github-actions/expressions
# - Workflow commands & env files: https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions

name: Codex - Auto Iterate on CI Failure

on:
  push:
    branches: ['**']
  workflow_dispatch: {}
  # Keep this commented unless you still want workflow_run triggering too.
  # workflow_run:
  #   workflows: ['Batch syntax/run check']
  #   types: [completed]

permissions:
  actions: read
  contents: write
  pull-requests: write

concurrency:
  group: codex-iterate-${{ github.sha }}
  cancel-in-progress: true

jobs:
  iterate:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      MAX_ATTEMPTS: '20'
      OPENAI_MODEL: gpt-4o-mini
      ITERATE_WORKFLOW_NAME: ${{ github.workflow }} # name of this workflow, used to exclude self from polling list
      POLL_TIMEOUT_SECONDS: '600' # 10 minutes
      POLL_INTERVAL_SECONDS: '10'

    steps:
      - name: Debug event
        run: |
          echo "event=${{ github.event_name }}"
          echo "ref_name=${{ github.ref_name }}"
          echo "sha=${{ github.sha }}"
          echo "actor=${{ github.actor }}"
          echo "workflow=${{ github.workflow }}"

      - name: Checkout repo (latest)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Auth probe (key + 1-token chat)
        id: auth
        continue-on-error: true
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: ${{ env.OPENAI_MODEL }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "ok=false" >> "$GITHUB_OUTPUT"
            echo "reason=no_key" >> "$GITHUB_OUTPUT"
            {
              echo "### Auth probe"
              echo ""
              echo "- key: MISSING"
            } >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi
          REQ="$RUNNER_TEMP/auth_req.json"
          cat > "$REQ" <<'JSON'
          {
            "model": "gpt-4o-mini",
            "messages": [{"role":"user","content":"ping"}],
            "max_tokens": 1,
            "temperature": 0
          }
          JSON
          http_code=$(curl -sS -o "$RUNNER_TEMP/auth_body.json" -w "%{http_code}" \
            https://api.openai.com/v1/chat/completions \
            -H "authorization: Bearer $OPENAI_API_KEY" \
            -H "content-type: application/json" \
            -d @"$REQ")
          if [ "$http_code" = "200" ]; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
            echo "reason=ok" >> "$GITHUB_OUTPUT"
          else
            echo "ok=false" >> "$GITHUB_OUTPUT"
            echo "reason=http_${http_code}" >> "$GITHUB_OUTPUT"
          fi
          {
            echo "### Auth probe"
            echo ""
            if [ "$http_code" = "200" ]; then echo "- key: present"; else echo "- key: present (but request failed)"; fi
            echo "- http_code: $http_code"
            echo ""
            echo "Body (first 400 chars):"
            echo '```json'
            head -c 400 "$RUNNER_TEMP/auth_body.json" | sed 's/[^[:print:]\t]/?/g' || true
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Gather context
        id: ctx
        shell: bash
        run: |
          set -euo pipefail
          branch="${{ github.ref_name }}"
          sha="${{ github.sha }}"
          run_id="${{ github.run_id }}"
          run_url="https://github.com/${{ github.repository }}/actions/runs/${run_id}"
          branch_slug=$(echo "$branch" | tr ':/ ' '---')
          echo "branch=$branch" >> "$GITHUB_OUTPUT"
          echo "branch_slug=$branch_slug" >> "$GITHUB_OUTPUT"
          echo "head_sha=$sha" >> "$GITHUB_OUTPUT"
          echo "run_id=$run_id" >> "$GITHUB_OUTPUT"
          echo "run_url=$run_url" >> "$GITHUB_OUTPUT"

      - name: Poll main CI run for this commit (push path)
        id: poll
        uses: actions/github-script@v7
        env:
          ITERATE_WORKFLOW_NAME: ${{ env.ITERATE_WORKFLOW_NAME }}
          POLL_TIMEOUT_SECONDS: ${{ env.POLL_TIMEOUT_SECONDS }}
          POLL_INTERVAL_SECONDS: ${{ env.POLL_INTERVAL_SECONDS }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = context.sha;
            const selfName = process.env.ITERATE_WORKFLOW_NAME || context.workflow;
            const pollDeadline = Date.now() + (parseInt(process.env.POLL_TIMEOUT_SECONDS||"600")*1000);
            const interval = parseInt(process.env.POLL_INTERVAL_SECONDS||"10")*1000;

            function isMainCandidate(run) {
              const nm = (run.name || "").toLowerCase();
              if (nm === (selfName||"").toLowerCase()) return false;
              if (nm.includes("iterate")) return false;
              return run.head_sha === sha;
            }

            async function listRuns() {
              const { data } = await github.rest.actions.listWorkflowRunsForRepo({
                owner, repo, per_page: 100, head_sha: sha
              });
              return data.workflow_runs.filter(isMainCandidate);
            }

            let chosen = null;
            while (Date.now() < pollDeadline) {
              const runs = await listRuns();
              if (runs.length > 0) {
                runs.sort((a,b)=> new Date(b.created_at)-new Date(a.created_at));
                chosen = runs[0];
                if (chosen.status === "completed") break;
              }
              await new Promise(r => setTimeout(r, interval));
            }

            if (!chosen) {
              core.info("No main CI run found for this commit within timeout; will iterate (assume CI did not start).");
              core.setOutput("found", "false");
              core.setOutput("status", "missing");
              core.setOutput("conclusion", "");
              core.setOutput("run_id", "");
            } else {
              core.info(`Main candidate: ${chosen.name} id=${chosen.id} status=${chosen.status} conclusion=${chosen.conclusion}`);
              core.setOutput("found", "true");
              core.setOutput("status", chosen.status || "");
              core.setOutput("conclusion", chosen.conclusion || "");
              core.setOutput("run_id", String(chosen.id));
              core.setOutput("name", chosen.name || "");
              core.setOutput("html_url", chosen.html_url || "");
            }

      - name: Decide gate (iterate vs skip)
        id: gate
        shell: bash
        env:
          FOUND: ${{ steps.poll.outputs.found }}
          STATUS: ${{ steps.poll.outputs.status }}
          CONCLUSION: ${{ steps.poll.outputs.conclusion }}
        run: |
          set -euo pipefail
          should_iterate=false
          reason=""
          if [ "${FOUND}" != "true" ]; then
            should_iterate=true
            reason="no_main_run_found"
          else
            if [ "${STATUS}" != "completed" ]; then
              should_iterate=true
              reason="main_run_not_completed"
            else
              if [ "${CONCLUSION}" != "success" ]; then
                should_iterate=true
                reason="main_conclusion_${CONCLUSION:-empty}"
              else
                should_iterate=false
                reason="main_success"
              fi
            fi
          fi
          echo "should_iterate=${should_iterate}" >> "$GITHUB_OUTPUT"
          echo "reason=${reason}" >> "$GITHUB_OUTPUT"
          echo "Gate: should_iterate=${should_iterate} reason=${reason}"

      - name: Load/Update attempt counter
        if: ${{ steps.gate.outputs.should_iterate == 'true' }}
        id: attempts
        shell: bash
        run: |
          set -euo pipefail
          attempts=0
          GH_TOKEN="${{ github.token }}"
          owner_repo="${{ github.repository }}"
          branch_slug="${{ steps.ctx.outputs.branch_slug }}"
          curl -sS -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/repos/${owner_repo}/actions/artifacts?per_page=100" > artifacts_all.json
          id=$(jq -r --arg n "iterate-state-$branch_slug" '.artifacts[] | select(.name==$n and .expired==false) | .id' artifacts_all.json | head -n 1 || true)
          if [ -n "$id" ] && [ "$id" != "null" ]; then
            curl -sSL -H "Authorization: Bearer $GH_TOKEN" -L \
              "https://api.github.com/repos/${owner_repo}/actions/artifacts/$id/zip" \
              -o state.zip || true
            mkdir -p state && unzip -q state.zip -d state || true
            attempts=$(jq -r '.attempts // 0' state/iterate_state.json 2>/dev/null || echo 0)
          fi
          next=$(( attempts + 1 ))
          if [ "$next" -gt "${MAX_ATTEMPTS}" ]; then
            echo "stop=true" >> "$GITHUB_OUTPUT"
            echo "stop_reason=Max attempts reached (${MAX_ATTEMPTS})" >> "$GITHUB_OUTPUT"
            echo "previous=$attempts" >> "$GITHUB_OUTPUT"
            echo "next=$attempts" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "stop=false" >> "$GITHUB_OUTPUT"
          echo "previous=$attempts" >> "$GITHUB_OUTPUT"
          echo "next=$next" >> "$GITHUB_OUTPUT"

      - name: Build prompt
        if: ${{ steps.gate.outputs.should_iterate == 'true' && steps.attempts.outputs.stop != 'true' }}
        id: prompt
        shell: bash
        run: |
          set -euo pipefail
          PROMPT="$RUNNER_TEMP/prompt.txt"
          repo="${{ github.repository }}"
          branch="${{ steps.ctx.outputs.branch }}"
          sha="${{ steps.ctx.outputs.head_sha }}"
          run_id="${{ steps.poll.outputs.run_id || steps.ctx.outputs.run_id }}"
          run_url="${{ steps.poll.outputs.html_url || steps.ctx.outputs.run_url }}"
          attempt="${{ steps.attempts.outputs.next }}"
          {
            echo "You are Codex. You have a working copy of the repo checked out."
            echo "Read README.md and AGENTS.md (if present) in the workspace for local policy."
            echo ""
            echo "Task: diagnose and fix CI failures for the GitHub Actions workflow(s)."
            echo "Prefer minimal edits and explain changes in commit messages."
            echo ""
            echo "Repo: $repo"
            echo "Branch: $branch"
            echo "Commit: $sha"
            echo "Upstream run (that triggered this or was expected to): ${run_url:-none}"
            echo "Attempt: $attempt/${MAX_ATTEMPTS}"
            echo ""
            echo "Strict output instruction: Return a unified diff patch inside a single fenced code block labeled 'diff'."
            echo "If no changes are needed, output exactly: ```diff"
            echo "# no changes"
            echo "```"
          } > "$PROMPT"
          echo "path=$PROMPT" >> "$GITHUB_OUTPUT"

      - name: Prompt preview
        if: ${{ steps.gate.outputs.should_iterate == 'true' && steps.attempts.outputs.stop != 'true' }}
        run: |
          {
            echo "### Prompt (first 120 lines)"
            echo '```text'
            head -n 120 "${{ steps.prompt.outputs.path }}"
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Ask model for patch
        if: ${{ steps.gate.outputs.should_iterate == 'true' && steps.attempts.outputs.stop != 'true' && steps.auth.outputs.ok == 'true' }}
        id: llm
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: ${{ env.OPENAI_MODEL }}
        shell: bash
        run: |
          set -euo pipefail
          REQ="$RUNNER_TEMP/llm_req.json"
          RES="$RUNNER_TEMP/llm_res.json"
          PROMPT_FILE="${{ steps.prompt.outputs.path }}"
          jq -Rs '.' < "$PROMPT_FILE" > "$RUNNER_TEMP/prompt.json"
          cat > "$REQ" <<JSON
          {
            "model": "${OPENAI_MODEL}",
            "messages": [
              {"role": "system", "content": "You are an expert software engineer that proposes precise, minimal unified diffs."},
              {"role": "user", "content": $(cat "$RUNNER_TEMP/prompt.json")}
            ],
            "temperature": 0,
            "max_tokens": 2000
          }
          JSON
          http_code=$(curl -sS -o "$RES" -w "%{http_code}" \
            https://api.openai.com/v1/chat/completions \
            -H "authorization: Bearer $OPENAI_API_KEY" \
            -H "content-type: application/json" \
            -d @"$REQ")
          echo "http_code=$http_code"
          CONTENT="$RUNNER_TEMP/llm_content.txt"
          jq -r '.choices[0].message.content // ""' "$RES" > "$CONTENT" || true
          {
            echo "### LLM response (first 120 lines)"
            echo '```'
            head -n 120 "$CONTENT"
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Extract fenced diff
        if: ${{ steps.gate.outputs.should_iterate == 'true' && steps.attempts.outputs.stop != 'true' && steps.auth.outputs.ok == 'true' }}
        id: diff
        shell: bash
        run: |
          set -euo pipefail
          CONTENT="$RUNNER_TEMP/llm_content.txt"
          DIFF_OUT="$RUNNER_TEMP/patch.diff"
          awk 'BEGIN{f=0} /```diff/ && f==0 {f=1; next} /```/ && f==1 {f=2} f==1 {print}' "$CONTENT" > "$DIFF_OUT" || true
          if [ ! -s "$DIFF_OUT" ]; then
            echo "# no changes" > "$DIFF_OUT"
          fi
          echo "diff_path=$DIFF_OUT" >> "$GITHUB_OUTPUT"
          echo "### Extracted diff (first 120 lines)" >> "$GITHUB_STEP_SUMMARY"
          echo '```diff' >> "$GITHUB_STEP_SUMMARY"
          head -n 120 "$DIFF_OUT" >> "$GITHUB_STEP_SUMMARY" || true
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - name: Apply patch
        if: ${{ steps.gate.outputs.should_iterate == 'true' && steps.attempts.outputs.stop != 'true' && steps.auth.outputs.ok == 'true' }}
        id: apply
        shell: bash
        run: |
          set -euo pipefail
          DIFF_OUT="${{ steps.diff.outputs.diff_path }}"
          if grep -q '^# no changes$' "$DIFF_OUT"; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if git apply -p0 --index "$DIFF_OUT"; then
            echo "applied_with=-p0" >> "$GITHUB_OUTPUT"
          elif git apply -p1 --index "$DIFF_OUT"; then
            echo "applied_with=-p1" >> "$GITHUB_OUTPUT"
          else
            echo "Patch failed to apply"
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if [ -z "$(git status --porcelain)" ]; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git config user.name  "github-actions[bot]"
            git commit -m "codex: apply suggested patch (attempt ${{ steps.attempts.outputs.next }}/${{ env.MAX_ATTEMPTS }})"
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Build PR body file
        if: ${{ steps.gate.outputs.should_iterate == 'true' }}
        id: pr_body
        shell: bash
        run: |
          set -euo pipefail
          BODY=".github/ITERATE_PR_BODY.md"
          mkdir -p .github
          {
            echo "## Codex iteration (push-poll flow)"
            echo
            echo "- Branch: \`${{ steps.ctx.outputs.branch }}\` @ ${{ steps.ctx.outputs.head_sha }}"
            if [ -n "${{ steps.poll.outputs.html_url }}" ]; then
              echo "- Polled main run: ${{ steps.poll.outputs.name }} – ${{ steps.poll.outputs.html_url }} (conclusion: ${{ steps.poll.outputs.conclusion || 'n/a' }})"
            else
              echo "- Polled main run: none detected for this commit (within timeout)"
            fi
            echo
            echo "### Auth probe"
            echo "- ok: ${{ steps.auth.outputs.ok || 'false' }} (reason: ${{ steps.auth.outputs.reason || 'n/a' }})"
            echo
            if [ -f "$RUNNER_TEMP/prompt.txt" ]; then
              echo "### Prompt (first 200 lines)"
              echo '```text'
              head -n 200 "$RUNNER_TEMP/prompt.txt" || true
              echo '```'
            fi
            if [ -f "$RUNNER_TEMP/patch.diff" ]; then
              echo
              echo "### Extracted diff (first 200 lines)"
              echo '```diff'
              head -n 200 "$RUNNER_TEMP/patch.diff" || true
              echo '```'
            fi
          } > "$BODY"
          echo "body_path=$BODY" >> "$GITHUB_OUTPUT"

      - name: Create PR (if edits)
        if: ${{ steps.apply.outputs.changed == 'true' }}
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "codex: iterate on CI failure (attempt ${{ steps.attempts.outputs.next }}/${{ env.MAX_ATTEMPTS }})"
          branch: codex/ci-fix-${{ steps.ctx.outputs.branch_slug }}
          base: ${{ steps.ctx.outputs.branch }}
          title: "Codex: iterate on CI failure – ${{ steps.ctx.outputs.branch }}"
          body-path: ${{ steps.pr_body.outputs.body_path }}
          labels: codex,ci-fix,automerge-candidate

      - name: Upload diagnostics
        uses: actions/upload-artifact@v4
        with:
          name: iterate-diag-${{ github.run_id }}-${{ github.run_attempt }}
          path: |
            $RUNNER_TEMP/auth_body.json
            $RUNNER_TEMP/llm_req.json
            $RUNNER_TEMP/llm_res.json
            $RUNNER_TEMP/llm_content.txt
            $RUNNER_TEMP/patch.diff
            $RUNNER_TEMP/prompt.txt
            artifacts/**
          if-no-files-found: ignore
          retention-days: 14

      - name: Save attempt state
        if: ${{ steps.gate.outputs.should_iterate == 'true' && steps.attempts.outputs.stop != 'true' }}
        shell: bash
        run: |
          mkdir -p state_out
          cat > state_out/iterate_state.json <<'JSON'
          {
            "attempts": ${{ steps.attempts.outputs.next }},
            "run_id": "${{ steps.ctx.outputs.run_id }}",
            "head_sha": "${{ steps.ctx.outputs.head_sha }}"
          }
          JSON

      - name: Upload attempt state
        if: ${{ steps.gate.outputs.should_iterate == 'true' && steps.attempts.outputs.stop != 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: iterate-state-${{ steps.ctx.outputs.branch_slug }}
          path: state_out
          if-no-files-found: ignore
          retention-days: 30
