# yamllint disable rule:line-length rule:truthy rule:colons rule:document-start
name: Codex - Auto Iterate on CI Failure

on:
  push:
    branches: ['**']
  workflow_dispatch: {}

permissions:
  actions: write
  contents: write
  pull-requests: write

defaults:
  run:
    shell: bash

concurrency:
  group: codex-iterate-${{ github.sha }}
  cancel-in-progress: true

jobs:
  iterate:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      ATTEMPT_LIMIT: '4'
      OPENAI_MODEL: gpt-4o-mini
    steps:
      - name: Debug event
        run: |
          echo "event=${{ github.event_name }}"
          echo "ref_name=${{ github.ref_name }}"
          echo "sha=${{ github.sha }}"
          echo "actor=${{ github.actor }}"
          echo "workflow=${{ github.workflow }}"
          echo "run_id=${{ github.run_id }}"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git user
        run: |
          git config user.name 'github-actions[bot]'
          git config user.email 'github-actions[bot]@users.noreply.github.com'

      - name: Gather context
        id: ctx
        run: |
          set -euo pipefail
          branch="${{ github.ref_name }}"
          branch_slug=$(echo "$branch" | tr ':/ ' '---')
          echo "branch=$branch" >> "$GITHUB_OUTPUT"
          echo "branch_slug=$branch_slug" >> "$GITHUB_OUTPUT"
          echo "head_sha=${{ github.sha }}" >> "$GITHUB_OUTPUT"
          echo "run_id=${{ github.run_id }}" >> "$GITHUB_OUTPUT"
          echo "run_attempt=${{ github.run_attempt }}" >> "$GITHUB_OUTPUT"

      - name: Poll latest upstream workflow run
        id: poll
        uses: actions/github-script@v7
        env:
          POLL_TIMEOUT_SECONDS: '900'
          POLL_INTERVAL_SECONDS: '10'
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = context.sha;
            const selfRunId = String(context.runId);
            const selfName = (context.workflow || '').toLowerCase();
            const timeout = Date.now() + (parseInt(process.env.POLL_TIMEOUT_SECONDS || '900', 10) * 1000);
            const interval = parseInt(process.env.POLL_INTERVAL_SECONDS || '10', 10) * 1000;

            async function fetchRuns() {
              const { data } = await github.rest.actions.listWorkflowRunsForRepo({ owner, repo, head_sha: sha, per_page: 100 });
              return (data.workflow_runs || [])
                .filter(run => String(run.id) !== selfRunId && (run.name || '').toLowerCase() !== selfName)
                .sort((a, b) => new Date(b.run_started_at || b.created_at || 0) - new Date(a.run_started_at || a.created_at || 0));
            }

            let chosen = null;
            let lastSeen = [];
            while (Date.now() < timeout) {
              const runs = await fetchRuns();
              lastSeen = runs.map(run => ({
                id: run.id,
                name: run.name,
                status: run.status,
                conclusion: run.conclusion,
                run_attempt: run.run_attempt,
              }));
              if (runs.length === 0) {
                await new Promise(r => setTimeout(r, interval));
                continue;
              }
              const latest = runs[0];
              if (latest.status !== 'completed') {
                await new Promise(r => setTimeout(r, interval));
                continue;
              }
              chosen = latest;
              break;
            }

            core.setOutput('summary_json', JSON.stringify(lastSeen));
            if (!chosen) {
              core.setOutput('picked_id', '');
              core.setOutput('picked_conclusion', '');
              core.setOutput('picked_name', '');
              core.setOutput('picked_attempt', '');
            } else {
              core.setOutput('picked_id', String(chosen.id));
              core.setOutput('picked_conclusion', chosen.conclusion || '');
              core.setOutput('picked_name', chosen.name || '');
              core.setOutput('picked_attempt', String(chosen.run_attempt || ''));
            }

      - name: Collect upstream diagnostics
        id: inputs
        env:
          GH_TOKEN: ${{ github.token }}
          RUN_ID: ${{ steps.poll.outputs.picked_id }}
        run: |
          set -euo pipefail
          INPUT_DIR="$RUNNER_TEMP/iterate_inputs"
          mkdir -p "$INPUT_DIR"
          if [ -z "${RUN_ID:-}" ]; then
            echo 'No upstream workflow run found for this commit.' > "$INPUT_DIR/placeholder.txt"
            {
              echo "inputs_dir=$INPUT_DIR"
              echo "ndjson_found=false"
              echo "ndjson_empty=true"
              echo "ndjson_any_fail=false"
              echo "ndjson_passes=0"
              echo "ndjson_fails=0"
              echo "summary_first_failure=false"
              echo "gate_output_verdict="
              echo "upstream_conclusion="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi
          python tools/collect_iterate_inputs.py \
            --repo "${{ github.repository }}" \
            --run-id "${RUN_ID}" \
            --output "$INPUT_DIR" \
            --token "$GH_TOKEN"
          echo "inputs_dir=$INPUT_DIR" >> "$GITHUB_OUTPUT"

      - name: Decide gate (iterate vs skip)
        id: gate
        env:
          RUN_ID: ${{ steps.poll.outputs.picked_id }}
          CONCLUSION: ${{ steps.poll.outputs.picked_conclusion }}
          NDJSON_FOUND: ${{ steps.inputs.outputs.ndjson_found }}
          NDJSON_EMPTY: ${{ steps.inputs.outputs.ndjson_empty }}
          NDJSON_ANY_FAIL: ${{ steps.inputs.outputs.ndjson_any_fail }}
          SUMMARY_FIRST_FAILURE: ${{ steps.inputs.outputs.summary_first_failure }}
          GATE_VERDICT: ${{ steps.inputs.outputs.gate_output_verdict }}
        run: |
          set -euo pipefail
          should_iterate=false
          reason=""

          if [ -z "${RUN_ID:-}" ]; then
            should_iterate=true
            reason="no_upstream_run"
          else
            conclusion="${CONCLUSION:-success}"
            ndjson_found="${NDJSON_FOUND:-false}"
            ndjson_empty="${NDJSON_EMPTY:-true}"
            ndjson_any_fail="${NDJSON_ANY_FAIL:-false}"
            first_failure="${SUMMARY_FIRST_FAILURE:-false}"
            gate_verdict="${GATE_VERDICT:-}"

            if [ "$conclusion" != "success" ] && [ -n "$conclusion" ]; then
              should_iterate=true
              reason="upstream_${conclusion}"
            elif [ "$ndjson_found" != "true" ]; then
              should_iterate=true
              reason="ndjson_missing"
            elif [ "$ndjson_empty" = "true" ]; then
              should_iterate=true
              reason="ndjson_empty"
            elif [ "$ndjson_any_fail" = "true" ]; then
              should_iterate=true
              reason="ndjson_failures"
            elif [ "$first_failure" = "true" ]; then
              should_iterate=true
              reason="summary_first_failure"
            elif [ -n "$gate_verdict" ] && [ "$gate_verdict" = "fail" ]; then
              should_iterate=true
              reason="gate_output_fail"
            else
              should_iterate=false
              reason="all_clear"
            fi
          fi

          echo "should_iterate=$should_iterate" >> "$GITHUB_OUTPUT"
          echo "reason=$reason" >> "$GITHUB_OUTPUT"

          {
            echo "### Iterate gate"
            echo "- upstream_run: ${RUN_ID:-none}"
            echo "- conclusion: ${CONCLUSION:-unknown}"
            echo "- ndjson_found: ${NDJSON_FOUND:-false}"
            echo "- ndjson_empty: ${NDJSON_EMPTY:-true}"
            echo "- ndjson_any_fail: ${NDJSON_ANY_FAIL:-false}"
            echo "- summary_first_failure: ${SUMMARY_FIRST_FAILURE:-false}"
            echo "- gate_output_verdict: ${GATE_VERDICT:-n/a}"
            echo "- decision: ${should_iterate} (reason: ${reason})"
          } >> "$GITHUB_STEP_SUMMARY"

          if [ "$should_iterate" != "true" ]; then
            echo "gate: skipped (${reason})" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Upload iterate inputs bundle
        uses: actions/upload-artifact@v4
        with:
          name: iterate-inputs-${{ github.run_id }}-${{ github.run_attempt }}
          path: ${{ steps.inputs.outputs.inputs_dir }}
          if-no-files-found: ignore
          retention-days: 14

      - name: Initialize iterate status
        if: ${{ steps.gate.outputs.should_iterate == 'true' }}
        run: |
          : > "$RUNNER_TEMP/iterate_status.txt"

      - name: Preflight auth mini chat
        if: ${{ steps.gate.outputs.should_iterate == 'true' }}
        id: auth
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          MODEL: ${{ env.OPENAI_MODEL }}
        run: |
          set -euo pipefail
          STATUS_FILE="$RUNNER_TEMP/iterate_status.txt"
          REQ="$RUNNER_TEMP/llm_req.json"
          RES="$RUNNER_TEMP/llm_res.json"
          OUTTXT="$RUNNER_TEMP/llm_content.txt"
          : > "$OUTTXT"
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "ok=false" >> "$GITHUB_OUTPUT"
            echo "reason=no_key" >> "$GITHUB_OUTPUT"
            echo "Preflight: missing OPENAI_API_KEY" >> "$STATUS_FILE"
            exit 0
          fi
            cat > "$REQ" <<'JSON'
            {
              "model": "gpt-4o-mini",
              "input": [
                {"role": "user", "content": [{"type": "input_text", "text": "ping"}]}
              ],
              "max_output_tokens": 16
            }
            JSON
          http_code=$(curl -sS -o "$RES" -w "%{http_code}" \
            https://api.openai.com/v1/responses \
            -H "authorization: Bearer ${OPENAI_API_KEY}" \
            -H "content-type: application/json" \
            -d @"$REQ" || true)
          text=$(jq -r '(
            .output_text //
            (.output[]? | .content[]? | select(.type=="output_text") | .text) //
            (.output[0]? | .content[0]? | .text // "")
          )' "$RES" 2>/dev/null || true)
          printf '%s' "${text}" | head -c 2048 > "$OUTTXT"
          echo "Preflight HTTP: ${http_code}" >> "$STATUS_FILE"
          if [ "$http_code" = "200" ]; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
            echo "reason=ok" >> "$GITHUB_OUTPUT"
          else
            cp "$RES" "$RUNNER_TEMP/auth_body.json"
            echo "ok=false" >> "$GITHUB_OUTPUT"
            echo "reason=http_${http_code}" >> "$GITHUB_OUTPUT"
          fi
          {
            echo "### Auth mini chat"
            echo "- model: ${MODEL}"
            echo "- http_code: ${http_code}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Prepare preflight failure bundle
        if: ${{ steps.gate.outputs.should_iterate == 'true' && steps.auth.outputs.ok != 'true' }}
        run: |
          set -euo pipefail
          ATTEMPT_DIR="$RUNNER_TEMP/attempt_1"
          mkdir -p "$ATTEMPT_DIR"
          printf 'Preflight authentication failed; iteration loop skipped.\n' > "$ATTEMPT_DIR/prompt.txt"
          cp "$RUNNER_TEMP/llm_req.json" "$ATTEMPT_DIR/llm_req.json" || true
          cp "$RUNNER_TEMP/llm_res.json" "$ATTEMPT_DIR/llm_res.json" || true
          cp "$RUNNER_TEMP/llm_content.txt" "$ATTEMPT_DIR/llm_content.txt" || true
          cp "$RUNNER_TEMP/iterate_status.txt" "$ATTEMPT_DIR/iterate_status.txt" || true
          if [ -f "$RUNNER_TEMP/auth_body.json" ]; then
            cp "$RUNNER_TEMP/auth_body.json" "$ATTEMPT_DIR/auth_body.json"
          fi
          printf 'No Codex attempts were executed because the auth preflight failed.\n' > "$ATTEMPT_DIR/codex_exec.log"
          : > "$ATTEMPT_DIR/patch.diff"

      - name: Run Codex iterate loop
        if: ${{ steps.gate.outputs.should_iterate == 'true' && steps.auth.outputs.ok == 'true' }}
        id: iterate_loop
        env:
          INPUT_DIR: ${{ steps.inputs.outputs.inputs_dir }}
          BRANCH: ${{ steps.ctx.outputs.branch }}
          REPO: ${{ github.repository }}
          SHA: ${{ github.sha }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          STATUS_FILE="$RUNNER_TEMP/iterate_status.txt"
          attempt_limit=${ATTEMPT_LIMIT}
          pushed=false
          for attempt in $(seq 1 ${ATTEMPT_LIMIT}); do
            echo "attempt ${attempt}/${ATTEMPT_LIMIT}" | tee -a "$STATUS_FILE"
            git reset --hard HEAD >/dev/null
            git clean -fd >/dev/null
            attempt_dir="$RUNNER_TEMP/attempt_${attempt}"
            mkdir -p "$attempt_dir"
            prompt_file="$attempt_dir/prompt.txt"
            python tools/build_iterate_prompt.py \
              --inputs "$INPUT_DIR" \
              --output "$prompt_file" \
              --attempt "$attempt" \
              --total "$ATTEMPT_LIMIT" \
              --branch "$BRANCH" \
              --sha "$SHA" \
              --repo "$REPO"
            req_file="$attempt_dir/llm_req.json"
            res_file="$attempt_dir/llm_res.json"
            content_file="$attempt_dir/llm_content.txt"
              cat > "$req_file" <<JSON
              {
                "model": "${OPENAI_MODEL}",
                "input": [
                  {"role": "system", "content": [{"type": "input_text", "text": "Return only one unified diff that fixes the observed CI failures."}]},
                  {"role": "user", "content": [{"type": "input_text", "text": $(jq -Rs '.' "$prompt_file")}]}
                ],
                "temperature": 0.15,
                "max_output_tokens": 4000
              }
              JSON
            codex_log="$attempt_dir/codex_exec.log"
            http_code=$(curl -sS -o "$res_file" -w "%{http_code}" \
              https://api.openai.com/v1/responses \
              -H "authorization: Bearer ${OPENAI_API_KEY}" \
              -H "content-type: application/json" \
              -d @"$req_file" || true)
            echo "HTTP ${http_code}" > "$codex_log"
            text=$(jq -r '(
              .output_text //
              (.output[]? | .content[]? | select(.type=="output_text") | .text) //
              (.output[0]? | .content[0]? | .text // "")
            )' "$res_file" 2>/dev/null || true)
            printf '%s' "$text" > "$content_file"
            cp "$RUNNER_TEMP/iterate_status.txt" "$attempt_dir/iterate_status.txt"
            if [ "$http_code" != "200" ]; then
              echo "HTTP ${http_code} from Codex" >> "$STATUS_FILE"
              printf 'No diff extracted due to HTTP %s.\n' "$http_code" > "$attempt_dir/patch.diff"
              continue
            fi
            diff_file="$attempt_dir/patch.diff"
              python - "$content_file" "$diff_file" <<'PY'
              import sys
              from pathlib import Path
              source = Path(sys.argv[1]).read_text(encoding='utf-8', errors='ignore').splitlines()
              out = []
              inside = False
              for line in source:
                  if not inside and line.strip().startswith('```diff'):
                      inside = True
                      continue
                  if inside and line.strip() == '```':
                      break
                  if inside:
                      out.append(line)
              Path(sys.argv[2]).write_text('\n'.join(out) + ('\n' if out else ''), encoding='utf-8')
              PY
            if [ ! -s "$diff_file" ]; then
              echo "No diff returned in attempt ${attempt}" >> "$STATUS_FILE"
              printf '# no changes\n' > "$diff_file"
              continue
            fi
            if ! git apply --whitespace=nowarn "$diff_file"; then
              echo "Patch failed to apply on attempt ${attempt}" >> "$STATUS_FILE"
              continue
            fi
            if [ -z "$(git status --porcelain)" ]; then
              echo "Patch produced no changes on attempt ${attempt}" >> "$STATUS_FILE"
              continue
            git add -A
            reason="applied"
            commit_msg="codex: attempt ${attempt}/${ATTEMPT_LIMIT} â€“ ${reason}"
            git commit -m "$commit_msg" >/dev/null
            if git push origin HEAD:"$BRANCH"; then
              echo "Pushed commit ${commit_msg}" >> "$STATUS_FILE"
              pushed=true
              break
            else
              echo "Push failed on attempt ${attempt}" >> "$STATUS_FILE"
            fi
          done
          echo "pushed=${pushed}" >> "$GITHUB_OUTPUT"

      - name: Discover attempt bundles
        if: ${{ always() }}
        id: attempt_paths
        run: |
          set -euo pipefail
          for i in $(seq 1 ${ATTEMPT_LIMIT}); do
            dir="$RUNNER_TEMP/attempt_${i}"
            if [ -d "$dir" ]; then
              cp "$RUNNER_TEMP/iterate_status.txt" "$dir/iterate_status.txt" 2>/dev/null || true
              echo "attempt_${i}_dir=$dir" >> "$GITHUB_OUTPUT"
            fi
          done

      - name: Upload diagnostics (attempt 1)
        if: ${{ steps.attempt_paths.outputs.attempt_1_dir != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: iterate-diag-${{ github.run_id }}-${{ github.run_attempt }}-1
          path: ${{ steps.attempt_paths.outputs.attempt_1_dir }}
          if-no-files-found: warn
          retention-days: 14

      - name: Upload diagnostics (attempt 2)
        if: ${{ steps.attempt_paths.outputs.attempt_2_dir != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: iterate-diag-${{ github.run_id }}-${{ github.run_attempt }}-2
          path: ${{ steps.attempt_paths.outputs.attempt_2_dir }}
          if-no-files-found: warn
          retention-days: 14

      - name: Upload diagnostics (attempt 3)
        if: ${{ steps.attempt_paths.outputs.attempt_3_dir != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: iterate-diag-${{ github.run_id }}-${{ github.run_attempt }}-3
          path: ${{ steps.attempt_paths.outputs.attempt_3_dir }}
          if-no-files-found: warn
          retention-days: 14

      - name: Upload diagnostics (attempt 4)
        if: ${{ steps.attempt_paths.outputs.attempt_4_dir != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: iterate-diag-${{ github.run_id }}-${{ github.run_attempt }}-4
          path: ${{ steps.attempt_paths.outputs.attempt_4_dir }}
          if-no-files-found: warn
          retention-days: 14

  deploy-iterate-pages:
    name: Deploy iterate diagnostics to Pages
    needs: iterate
    if: ${{ always() }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      pages: write
      id-token: write
    environment:
      name: github-pages
    steps:
      - name: Download iterate diagnostics artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: iterate-diag-*
          path: ${{ runner.temp }}/diag
          merge-multiple: false
          if-no-files-found: ignore

      - name: Stage diagnostics for Pages
        id: stage
        run: |
          set -euo pipefail
          rm -rf public
          mkdir -p public
          src_dir="$RUNNER_TEMP/diag"
          artifact_list=""
          if [ -d "$src_dir" ]; then
            shopt -s dotglob nullglob
            for entry in "$src_dir"/*; do
              if [ -d "$entry" ]; then
                base=$(basename "$entry")
                cp -R "$entry" "public/$base"
                artifact_list+="$base\n"
              fi
            done
            shopt -u dotglob nullglob
          fi
          printf '%s' "$artifact_list" > "$RUNNER_TEMP/diag_artifacts.txt"
          echo "artifacts=$(printf '%s' "$artifact_list" | paste -sd ',')" >> "$GITHUB_OUTPUT"

      - name: Render diagnostics index
        run: |
          set -euo pipefail
          python tools/render_iterate_index.py \
            --artifacts-root public \
            --output-dir public \
            --repo "${{ github.repository }}" \
            --sha "${{ github.sha }}" \
            --run-id "${{ github.run_id }}" \
            --run-attempt "${{ github.run_attempt }}"

      - name: Configure Pages
        uses: actions/configure-pages@v5

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: public

      - name: Deploy to Pages
        id: deploy
        uses: actions/deploy-pages@v4

      - name: Summarize deployment
        run: |
          url='${{ steps.deploy.outputs.page_url }}'
          artifacts='${{ steps.stage.outputs.artifacts }}'
          {
            echo '### Iterate diagnostics Pages'
            if [ -n "$url" ]; then
              echo "- Deployed: [$url]($url)"
            else
              echo '- Deployed: (no URL returned)'
            fi
            if [ -n "$artifacts" ]; then
              echo "- Artifacts: ${artifacts}"
            else
              echo '- Artifacts: none (fallback page published)'
            fi
          } >> "$GITHUB_STEP_SUMMARY"
