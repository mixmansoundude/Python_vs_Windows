# yamllint disable rule:line-length rule:truthy rule:colons rule:document-start
name: Codex – Auto Iterate on CI Failure
on:
  workflow_run:
    workflows: ["Batch syntax/run check"]   # keep this exact name
    types: [completed]
  workflow_dispatch: {}

permissions:
  actions: read
  contents: read

concurrency:
  group: codex-iterate-${{ github.event.workflow_run.head_branch }}
  cancel-in-progress: false

jobs:
  iterate:
    if: ${{ github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_run' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout failing branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}
          fetch-depth: 0

      # Preflight: detect the API key (do not echo it)
      - name: Check for OPENAI_API_KEY
        id: apikey
        shell: bash
        run: |
          if [ -n "${{ secrets.OPENAI_API_KEY }}" ]; then
            echo "present=true" >> "$GITHUB_OUTPUT"
          else
            echo "present=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Preflight OpenAI auth
        id: openai_auth
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.OPENAI_API_KEY }}" ]; then
            echo "present=false" >> "$GITHUB_OUTPUT"
            echo "auth_ok=false" >> "$GITHUB_OUTPUT"
            echo "http_code=000" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "present=true" >> "$GITHUB_OUTPUT"
          status=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.OPENAI_API_KEY }}" \
            https://api.openai.com/v1/models || echo 000)
          echo "http_code=$status" >> "$GITHUB_OUTPUT"
          if [ "$status" = "200" ]; then
            echo "auth_ok=true" >> "$GITHUB_OUTPUT"
          else
            echo "::warning title=OpenAI auth failed::HTTP $status from /v1/models (will skip Codex iteration)"
            echo "auth_ok=false" >> "$GITHUB_OUTPUT"
          fi

      - name: OpenAI chat ping (proof only)
        id: openai_chat
        if: steps.openai_auth.outputs.auth_ok == 'true'
        shell: bash
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          body='{"model":"gpt-4o-mini","messages":[{"role":"user","content":"Reply with PONG"}],"max_tokens":1}'
          resp=$(mktemp)
          code=$(curl -s -o "$resp" -w "%{http_code}" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$body" https://api.openai.com/v1/chat/completions || echo 000)
          echo "http_code=$code" >> "$GITHUB_OUTPUT"
          chat_flag=false
          if [ "$code" = "200" ]; then
            if python -c "import json, sys
            from pathlib import Path
            path = Path(sys.argv[1])
            try:
                data = json.loads(path.read_text(encoding='utf-8'))
            except Exception:
                sys.exit(1)
            text = ''
            for choice in data.get('choices', []):
                message = choice.get('message') or {}
                content = message.get('content')
                if isinstance(content, str):
                    text += content
            sys.exit(0 if 'PONG' in text.upper() else 1)
            " "$resp"; then
              chat_flag=true
            fi
          fi
          if [ "$chat_flag" = true ]; then
            echo "chat_ok=true" >> "$GITHUB_OUTPUT"
          else
            echo "chat_ok=false" >> "$GITHUB_OUTPUT"
          fi
          {
            echo "### Iterate chat ping"
            echo "- http_code: $code"
            if [ "$chat_flag" = true ]; then
              echo "- chat_ok: true"
            else
              echo "- chat_ok: false"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
          rm -f "$resp"

      # Keep CRLF stable (harmless even if we no-op)
      - name: Normalize CRLF
        run: |
          git config core.autocrlf true
          git config core.eol crlf

      - name: Iterate auth preflight
        if: ${{ always() }}
        run: |
          {
            echo "### Iterate auth preflight"
            echo "- api_key_present: ${{ steps.apikey.outputs.present || 'false' }}"
            echo "- http_code: ${{ steps.openai_auth.outputs.http_code || '000' }}"
            echo "- auth_ok: ${{ steps.openai_auth.outputs.auth_ok || 'false' }}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Skip Codex iteration (auth failure)
        if: steps.apikey.outputs.present == 'true' && steps.verdict.outputs.has_failures == 'true' && steps.openai_auth.outputs.auth_ok != 'true'
        run: |
          echo "::warning title=Codex iteration skipped::OpenAI authentication failed preflight."
          {
            echo "## Codex iteration"
            echo ""
            echo "Skipped because OpenAI authentication preflight failed (check iterate auth summary)."
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Skip Codex iteration (chat failure)
        if: steps.apikey.outputs.present == 'true' && steps.openai_auth.outputs.auth_ok == 'true' && steps.verdict.outputs.has_failures == 'true' && steps.openai_chat.outputs.chat_ok != 'true'
        run: |
          echo "::warning title=Codex iteration skipped::OpenAI chat ping failed; skipping headless iteration."
          {
            echo "## Codex iteration"
            echo ""
            echo "Skipped because chat ping failed (see Iterate chat ping summary for HTTP status and proof)."
          } >> "$GITHUB_STEP_SUMMARY"

      # Try to pull the failure hint artifact produced by the Windows job.
      # Note: For PR-triggered failures, there may be NO artifact (that job posts a PR comment instead).
      - name: Download codex_nudge.txt (if present)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: dawidd6/action-download-artifact@v3
        continue-on-error: true
        with:
          run_id: ${{ github.event.workflow_run.id }}
          name: codex_nudge-${{ github.event.workflow_run.id }}-${{ github.event.workflow_run.run_attempt }}
          path: ${{ runner.temp }}

      - name: Download CI summary (cache lane)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          run_id: ${{ github.event.workflow_run.id }}
          name: ci_test_summary-cache-${{ github.event.workflow_run.id }}-${{ github.event.workflow_run.run_attempt }}
          path: ${{ runner.temp }}/ci_summary_cache

      - name: Download CI summary (real lane)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          run_id: ${{ github.event.workflow_run.id }}
          name: ci_test_summary-real-${{ github.event.workflow_run.id }}-${{ github.event.workflow_run.run_attempt }}
          path: ${{ runner.temp }}/ci_summary_real

      - name: Download CI NDJSON (cache lane)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          run_id: ${{ github.event.workflow_run.id }}
          name: ci_test_results-cache-${{ github.event.workflow_run.id }}-${{ github.event.workflow_run.run_attempt }}
          path: ${{ runner.temp }}/ci_ndjson_cache

      - name: Download CI NDJSON (real lane)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          run_id: ${{ github.event.workflow_run.id }}
          name: ci_test_results-real-${{ github.event.workflow_run.id }}-${{ github.event.workflow_run.run_attempt }}
          path: ${{ runner.temp }}/ci_ndjson_real

      - name: Download diagnostics URL (if present)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          run_id: ${{ github.event.workflow_run.id }}
          name: codex_nudge_url-${{ github.event.workflow_run.id }}-${{ github.event.workflow_run.run_attempt }}
          path: ${{ runner.temp }}

      - name: Download logs for triggering run
        if: ${{ github.event_name == 'workflow_run' }}
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          RUN_ID="${{ github.event.workflow_run.id }}"
          curl -sSL -H "Authorization: Bearer $GH_TOKEN" \
               -o runlogs.zip \
               "https://api.github.com/repos/${{ github.repository }}/actions/runs/${RUN_ID}/logs"
          mkdir -p runlogs
          unzip -q runlogs.zip -d runlogs || true

      - name: Try to download NDJSON artifact(s)
        if: ${{ github.event_name == 'workflow_run' }}
        id: get_artifacts
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          RUN_ID="${{ github.event.workflow_run.id }}"
          curl -sS -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${RUN_ID}/artifacts" > artifacts.json
          mkdir -p artifacts
          for name in ci_test_results test-results tests-artifacts; do
            id=$(jq -r --arg n "$name" '.artifacts[] | select((.name|startswith($n))) | .id' artifacts.json | head -n 1)
            if [ -n "$id" ] && [ "$id" != "null" ]; then
              curl -sSL -H "Authorization: Bearer $GH_TOKEN" \
                -L "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/$id/zip" \
                -o "$name.zip" || true
              mkdir -p "artifacts/$name"
              unzip -q "$name.zip" -d "artifacts/$name" || true
            fi
          done

      - name: Determine NDJSON verdict
        id: verdict
        shell: pwsh
        env:
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          WORKFLOW_CONCLUSION: ${{ github.event.workflow_run.conclusion || '' }}
        run: |
          $ErrorActionPreference = 'Stop'

          $ndjsonGlobs = @(
            'artifacts/**/ci_test_results.ndjson',
            'artifacts/**/ci_test-results.ndjson',
            'artifacts/**/~test-results.ndjson',
            'ci_test_results.ndjson',
            'tests\~test-results.ndjson'
          )

          $found = @()
          foreach ($glob in $ndjsonGlobs) {
            $found += Get-ChildItem -Path $glob -File -ErrorAction SilentlyContinue |
              Select-Object -ExpandProperty FullName
          }
          $found = $found | Sort-Object -Unique

          $isManual = $env:GITHUB_EVENT_NAME -eq 'workflow_dispatch'

          if ($found.Count -eq 0) {
            if ($isManual) {
              'has_failures=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              Write-Host 'NDJSON verdict: manual run; no results; has_failures=false'
              return
            }
            'has_failures=true' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host 'NDJSON verdict: no results; has_failures=true'
            return
          }

          $fails = 0
          foreach ($file in $found) {
            Get-Content -LiteralPath $file | ForEach-Object {
              try {
                $row = $_ | ConvertFrom-Json
              } catch {
                return
              }
              if ($null -ne $row -and $row.pass -eq $false) { $fails++ }
            }
          }

          if ($fails -gt 0) {
            'has_failures=true' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "NDJSON verdict: $fails failing checks -> has_failures=true"
            return
          }

          if (-not $isManual -and $env:GITHUB_EVENT_NAME -eq 'workflow_run') {
            $red = $false
            $patterns = @(
              '(?i)\bERROR\b',
              '(?i)SyntaxError:',
              '(?i)not recognized as an internal or external command',
              '(?i)No module named pipreqs\.__main__',
              '(?i)artifact name already exists',
              '(?i)Failed to CreateArtifact'
            )

            if (Test-Path -LiteralPath 'runlogs') {
              Get-ChildItem -Path 'runlogs' -Recurse -File -ErrorAction SilentlyContinue | ForEach-Object {
                $content = Get-Content -LiteralPath $_.FullName -Raw -ErrorAction SilentlyContinue
                foreach ($pattern in $patterns) {
                  if ($content -match $pattern) {
                    $red = $true
                    Write-Host "Red-flag pattern '$pattern' found in $($_.FullName)"
                    break
                  }
                }
                if ($red) { return }
              }
            }

            if ($red) {
              'has_failures=true' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              "NDJSON clean but red-flag strings found in logs (see artifacts) — has_failures=true." |
                Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
              Write-Host 'NDJSON verdict: clean but red-flag strings detected -> has_failures=true'
              return
            }

            $conclusion = $env:WORKFLOW_CONCLUSION
            if ($conclusion) {
              $lower = $conclusion.ToLowerInvariant()
              if ($lower -ne 'success') {
                'has_failures=true' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
                "NDJSON clean but workflow conclusion was '$conclusion' — has_failures=true." |
                  Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
                Write-Host "NDJSON verdict: workflow conclusion=$conclusion -> has_failures=true"
                return
              }
            }
          }

          'has_failures=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host 'NDJSON verdict: all passing -> has_failures=false'

      # If the key is missing, loudly but cleanly skip (logs + summary + tiny artifact)
      - name: Skip (no OPENAI_API_KEY configured)
        if: steps.apikey.outputs.present != 'true'
        run: |
          echo "::notice title=Codex auto-iterate is disabled::Reason: OPENAI_API_KEY not set. Skipping headless iteration and leaving existing flow unchanged."
          {
            echo "# Codex auto-iterate skipped"
            echo ""
            echo "- **Reason:** `OPENAI_API_KEY` is not configured in repo **Settings → Secrets and variables → Actions**."
            echo "- **Effect:** No headless Codex run; existing behavior (manual Push / nudger / automerge) remains unchanged."
            echo ""
            echo "To enable: add a repository secret named **OPENAI_API_KEY** with your OpenAI API key."
          } >> "$GITHUB_STEP_SUMMARY"
          printf "Codex auto-iterate skipped: missing OPENAI_API_KEY\n" > codex_skip_reason.txt

      - name: Upload skip reason (artifact)
        if: steps.apikey.outputs.present != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: codex-skip-reason-${{ github.run_id }}-${{ github.run_attempt }}
          path: codex_skip_reason.txt
          if-no-files-found: ignore
          retention-days: 7

      # Only proceed with Codex path when the key exists
      - name: Install Codex CLI
        if: steps.apikey.outputs.present == 'true' && steps.openai_auth.outputs.auth_ok == 'true' && steps.openai_chat.outputs.chat_ok == 'true' && steps.verdict.outputs.has_failures == 'true'
        run: npm i -g @openai/codex@latest

      - name: Git author
        if: steps.apikey.outputs.present == 'true' && steps.openai_auth.outputs.auth_ok == 'true' && steps.openai_chat.outputs.chat_ok == 'true' && steps.verdict.outputs.has_failures == 'true'
        run: |
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name  "github-actions[bot]"

      # 20-attempt guard based on our standard commit prefix
      - name: Loop guard
        if: steps.apikey.outputs.present == 'true' && steps.openai_auth.outputs.auth_ok == 'true' && steps.openai_chat.outputs.chat_ok == 'true' && steps.verdict.outputs.has_failures == 'true'
        id: guard
        shell: bash
        run: |
          BRANCH="codex/ci-fix-${{ github.event.workflow_run.head_branch }}"
          echo "BRANCH=$BRANCH" >> $GITHUB_ENV
          COUNT=$(git rev-list --all --grep='^codex: iterate on CI failure' | wc -l || true)
          echo "count=$COUNT" >> $GITHUB_OUTPUT
          if [ "$COUNT" -ge 20 ]; then
            echo "stop=true" >> $GITHUB_OUTPUT
            echo "Reached 20 attempts; exiting without changes."
          else
            echo "stop=false" >> $GITHUB_OUTPUT
            echo "next=$((COUNT+1))" >> $GITHUB_OUTPUT
          fi

      - name: Iterate gate debug
        if: ${{ always() }}
        env:
          NEEDS_JSON: ${{ toJson(needs) }}
        run: |
          echo "has_failures=${{ steps.verdict.outputs.has_failures }}"
          echo "apikey_present=${{ steps.apikey.outputs.present }}"
          echo "auth_ok=${{ steps.openai_auth.outputs.auth_ok }}"
          echo "chat_ok=${{ steps.openai_chat.outputs.chat_ok }}"
          echo "guard_stop=${{ steps.guard.outputs.stop }}"
          echo "event=${{ github.event_name }} ref=${{ github.ref }}"
          echo "needs.json=$NEEDS_JSON"

      - name: Iterate gate report
        if: ${{ always() }}
        run: |
          {
            echo "### Iterate gate report"
            echo "- api_key_present: ${{ steps.apikey.outputs.present || 'false' }}"
            echo "- auth_ok: ${{ steps.openai_auth.outputs.auth_ok || 'false' }}"
            echo "- chat_ok: ${{ steps.openai_chat.outputs.chat_ok || 'false' }}"
            echo "- has_failures: ${{ steps.verdict.outputs.has_failures || 'n/a' }}"
            echo "- event: ${{ github.event_name }}"
            if [ "${{ github.event_name }}" = "workflow_run" ]; then
              echo "- triggering_run: https://github.com/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}"
            fi
            echo "- logs_downloaded: $([ -d runlogs ] && echo true || echo false)"
            echo "- artifacts_downloaded: $([ -d artifacts ] && echo true || echo false)"
            URL_FILE=$(find "$RUNNER_TEMP" -maxdepth 2 -name "codex_nudge_url.txt" | head -n 1 || true)
            if [ -n "$URL_FILE" ] && [ -f "$URL_FILE" ]; then
              echo "- diagnostics_url: $(cat "$URL_FILE")"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Build prompt for Codex
        if: steps.apikey.outputs.present == 'true' && steps.openai_auth.outputs.auth_ok == 'true' && steps.openai_chat.outputs.chat_ok == 'true' && steps.guard.outputs.stop == 'false' && steps.verdict.outputs.has_failures == 'true'
        run: |
          PROMPT="$RUNNER_TEMP/prompt.txt"
          # Seed with the existing nudge or fallback
          NUDGE_PATH=""
          if [ -f "$RUNNER_TEMP/codex_nudge.txt" ]; then
            NUDGE_PATH="$RUNNER_TEMP/codex_nudge.txt"
          else
            NUDGE_PATH=$(find "$RUNNER_TEMP" -maxdepth 2 -name "codex_nudge.txt" | head -n 1 || true)
          fi
          if [ -n "$NUDGE_PATH" ] && [ -f "$NUDGE_PATH" ]; then
            BASE="$(cat "$NUDGE_PATH")"
          else
            BASE="Analyze the last CI failure and apply the smallest safe change set to make our Windows CI pass."
          fi
          printf "%s\n\nPreserve CRLF; ASCII where practical; keep run_setup.bat robust; avoid sweeping refactors; minimal diagnostics only if required; write changes to files.\n" "$BASE" > "$PROMPT"

          # If we have the human-readable summary, include it verbatim
          for summary_dir in "$RUNNER_TEMP"/ci_summary_*; do
            if [ -f "$summary_dir/tests/~test-summary.txt" ]; then
              {
                echo ""
                echo "----- CI Summary ($(basename "$summary_dir")) -----"
                head -n 300 "$summary_dir/tests/~test-summary.txt"
              } >> "$PROMPT"
            fi
          done
          if [ -f "$RUNNER_TEMP/ci_test_summary.txt/ci_test_summary.txt" ]; then
            {
              echo ""
              echo "----- CI Summary -----"
              head -n 300 "$RUNNER_TEMP/ci_test_summary.txt/ci_test_summary.txt"
            } >> "$PROMPT"
          fi

          # If we have the NDJSON, include the first ~40 lines for structured hints
          for ndjson_dir in "$RUNNER_TEMP"/ci_ndjson_*; do
            if [ -f "$ndjson_dir/tests/~test-results.ndjson" ]; then
              {
                echo ""
                echo "----- CI NDJSON ($(basename "$ndjson_dir")) (first lines) -----"
                head -n 40 "$ndjson_dir/tests/~test-results.ndjson"
              } >> "$PROMPT"
            fi
          done
          if [ -f "$RUNNER_TEMP/ci_test_results.ndjson/ci_test-results.ndjson" ]; then
            {
              echo ""
              echo "----- CI NDJSON (first lines) -----"
              head -n 40 "$RUNNER_TEMP/ci_test_results.ndjson/ci_test-results.ndjson"
            } >> "$PROMPT"
          fi

          URL_FILE=$(find "$RUNNER_TEMP" -maxdepth 2 -name "codex_nudge_url.txt" | head -n 1 || true)
          if [ -n "$URL_FILE" ] && [ -f "$URL_FILE" ]; then
            {
              echo ""
              echo "Diagnostics site: $(cat "$URL_FILE")"
            } >> "$PROMPT"
          fi

          echo "PROMPT=$PROMPT" >> $GITHUB_ENV

      - name: Run Codex headlessly (gpt-4o-mini, write-enabled)
        if: steps.apikey.outputs.present == 'true' && steps.openai_auth.outputs.auth_ok == 'true' && steps.openai_chat.outputs.chat_ok == 'true' && steps.verdict.outputs.has_failures == 'true' && steps.guard.outputs.stop == 'false'
        id: codex_exec
        timeout-minutes: 10
        continue-on-error: true
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -o pipefail
          codex -a never --sandbox workspace-write exec --model gpt-4o-mini "$(cat "$PROMPT")" 2>&1 | tee "$RUNNER_TEMP/codex_exec.log" || true

      - name: Upload Codex exec log
        if: ${{ always() && steps.codex_exec.outcome != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: codex_exec-${{ github.run_id }}-${{ github.run_attempt }}
          path: ${{ runner.temp }}/codex_exec.log
          if-no-files-found: ignore
          retention-days: 7

      - name: Summarize Codex outcome
        if: steps.apikey.outputs.present == 'true' && steps.openai_auth.outputs.auth_ok == 'true' && steps.openai_chat.outputs.chat_ok == 'true' && steps.guard.outputs.stop == 'false' && steps.verdict.outputs.has_failures == 'true'
        run: |
          echo "## Codex iterate summary" >> "$GITHUB_STEP_SUMMARY"
          if [ -f "$RUNNER_TEMP/codex_exec.log" ]; then
            if grep -qi 'stream error' "$RUNNER_TEMP/codex_exec.log"; then
              echo "- Stream errors occurred during Codex run (see codex-exec-log)." >> "$GITHUB_STEP_SUMMARY"
            fi
            tail -n 40 "$RUNNER_TEMP/codex_exec.log" | sed 's/\x1b\[[0-9;]*m//g' >> "$GITHUB_STEP_SUMMARY"
          else
            echo "- No Codex log found." >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Detect changes
        if: steps.apikey.outputs.present == 'true' && steps.openai_auth.outputs.auth_ok == 'true' && steps.openai_chat.outputs.chat_ok == 'true' && steps.guard.outputs.stop == 'false' && steps.verdict.outputs.has_failures == 'true'
        id: diffcheck
        run: |
          if [ -z "$(git status --porcelain)" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Summarize no-op Codex run
        if: steps.apikey.outputs.present == 'true' && steps.openai_auth.outputs.auth_ok == 'true' && steps.openai_chat.outputs.chat_ok == 'true' && steps.guard.outputs.stop == 'false' && steps.diffcheck.outputs.changed == 'false' && steps.verdict.outputs.has_failures == 'true'
        run: |
          echo "::notice title=Codex iteration::Codex made no edits; see codex-exec-log artifact for details."
          {
            echo "## Codex iteration"
            echo ""
            echo "Codex made no edits; see codex-exec-log artifact for details."
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Clean up repo temp files
        if: steps.apikey.outputs.present == 'true' && steps.openai_auth.outputs.auth_ok == 'true' && steps.openai_chat.outputs.chat_ok == 'true' && steps.guard.outputs.stop == 'false' && steps.verdict.outputs.has_failures == 'true'
        run: |
          rm -f prompt.txt codex_nudge.txt codex_exec.log || true

      # Let the action stage/commit/push the working tree itself.
      # This avoids the "no changes" early exit when the tree is clean.
      - name: Create/Update PR (commit & push inside action)
        if: steps.apikey.outputs.present == 'true' && steps.openai_auth.outputs.auth_ok == 'true' && steps.openai_chat.outputs.chat_ok == 'true' && steps.guard.outputs.stop == 'false' && steps.diffcheck.outputs.changed == 'true' && steps.verdict.outputs.has_failures == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token:  ${{ secrets.GITHUB_TOKEN }}
          base:   ${{ github.event.workflow_run.head_branch }}
          branch: ${{ env.BRANCH }}
          title:  "Codex: iterate on CI failure – ${{ github.event.workflow_run.head_branch }}"
          body:   "Automated Codex iteration after CI failure. Preserved CRLF/ASCII; minimal edits."
          labels: codex,ci-fix,automerge-candidate
          commit-message: "codex: iterate on CI failure (attempt ${{ steps.guard.outputs.next }}/20) for ${{ github.event.workflow_run.head_branch }}"
