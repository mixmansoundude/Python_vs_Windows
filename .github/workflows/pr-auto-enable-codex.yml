name: PR Auto-Enable Auto-merge (codex label)
on:
  pull_request:
    types: [opened, labeled, unlabeled, synchronize, reopened, ready_for_review]
  check_suite:
    types: [completed]
  status: {}
permissions:
  pull-requests: write
  contents: read

jobs:
  auto_enable_codex:
    runs-on: ubuntu-latest
    steps:
      - name: Resolve candidate PR numbers for this event
        id: prs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            async function numbersFromEvent() {
              if (context.eventName === 'pull_request') {
                return [context.payload.pull_request.number];
              }
              // status/check_suite â†’ map SHA to PRs
              const sha = context.eventName === 'status'
                ? context.payload.sha
                : context.payload.check_suite?.head_sha;
              if (!sha) return [];
              const prs = await github.request('GET /repos/{owner}/{repo}/commits/{ref}/pulls', {
                owner, repo, ref: sha,
                headers: { accept: 'application/vnd.github.groot-preview+json' }
              });
              return prs.data.filter(pr => pr.state === 'open').map(pr => pr.number);
            }

            const nums = await numbersFromEvent();
            core.setOutput('numbers', JSON.stringify(nums));

      - name: Enable Auto-merge (Squash) on eligible PRs (label=codex)
        if: steps.prs.outputs.numbers != '[]'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const nums = JSON.parse(process.env.numbers || '[]');

            // Inline SQUASH to avoid Octokit 'method' variable conflict.
            const mutation = `
              mutation($id:ID!) {
                enablePullRequestAutoMerge(input: { pullRequestId: $id, mergeMethod: SQUASH }) {
                  clientMutationId
                }
              }
            `;

            for (const number of nums) {
              const { data: pr } = await github.pulls.get({ owner, repo, pull_number: number });

              // Must be open, not draft
              if (pr.state !== 'open' || pr.draft) { core.info(`#${number}: skip (closed/draft)`); continue; }

              // Same-repo only (skip forks)
              const isSameRepo = pr.head.repo?.full_name === pr.base.repo?.full_name;
              if (!isSameRepo) { core.info(`#${number}: skip (fork PR)`); continue; }

              // Require label "codex"; allow opt-out via "no-automerge"
              const labels = (pr.labels || []).map(l => (l.name || '').toLowerCase());
              if (!labels.includes('codex')) { core.info(`#${number}: skip (missing 'codex' label)`); continue; }
              if (labels.includes('no-automerge')) { core.info(`#${number}: skip (has 'no-automerge')`); continue; }

              try {
                await github.graphql(mutation, { id: pr.node_id });
                core.info(`#${number}: Auto-merge enabled (Squash). GitHub will merge when required checks pass.`);
              } catch (e) {
                const msg = String(e.message || '').split('\n')[0];
                // Treat "already enabled" as a benign no-op
                if (/already.*auto-merge/i.test(msg) || /already.*enabled/i.test(msg)) {
                  core.info(`#${number}: Auto-merge already enabled (noop).`);
                } else {
                  core.info(`#${number}: enable failed (${msg}). Will retry on next event.`);
                }
              }
            }
        env:
          numbers: ${{ steps.prs.outputs.numbers }}
