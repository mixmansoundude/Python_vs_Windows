name: PR Auto-Enable Auto-merge (codex label)

on:
  pull_request:
    types: [opened, labeled, unlabeled, synchronize, reopened, ready_for_review]
  check_suite:
    types: [completed]
  status: {}

permissions:
  pull-requests: write
  contents: read

jobs:
  auto_enable_codex:
    runs-on: ubuntu-latest
    steps:
      - name: Resolve candidate PR numbers for this event
        id: prs
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            async function numbersFromEvent() {
              if (context.eventName === 'pull_request') {
                return [context.payload.pull_request.number];
              }
              // Map status/check_suite SHA â†’ PRs using stable REST API
              const sha =
                context.eventName === 'status'
                  ? context.payload.sha
                  : context.payload.check_suite?.head_sha;

              if (!sha) return [];
              const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner, repo, commit_sha: sha
              });
              return prs.filter(pr => pr.state === 'open').map(pr => pr.number);
            }

            const nums = await numbersFromEvent();
            core.setOutput('numbers', JSON.stringify(nums));

      - name: Enable Auto-merge (Squash) on eligible PRs (label=codex)
        if: steps.prs.outputs.numbers != '[]'
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const nums = JSON.parse(process.env.numbers || '[]');

            // Inline SQUASH to avoid Octokit variable name conflicts
            const mutation = `
              mutation($id:ID!) {
                enablePullRequestAutoMerge(input: { pullRequestId: $id, mergeMethod: SQUASH }) {
                  clientMutationId
                }
              }
            `;

            for (const number of nums) {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: number });

              // Must be open, not draft
              if (pr.state !== 'open' || pr.draft) { core.info(`#${number}: skip (closed/draft)`); continue; }

              // Same-repo only (skip forks)
              const isSameRepo = pr.head.repo?.full_name === pr.base.repo?.full_name;
              if (!isSameRepo) { core.info(`#${number}: skip (fork PR)`); continue; }

              // Require label "codex"; allow opt-out via "no-automerge"
              const labels = (pr.labels || []).map(l => (l.name || '').toLowerCase());
              if (!labels.includes('codex')) { core.info(`#${number}: skip (missing 'codex' label)`); continue; }
              if (labels.includes('no-automerge')) { core.info(`#${number}: skip (has 'no-automerge')`); continue; }

              try {
                await github.graphql(mutation, { id: pr.node_id });
                core.info(`#${number}: Auto-merge enabled (Squash). GitHub will merge when required checks pass.`);
              } catch (e) {
                const msg = String(e.message || '').split('\n')[0];
                if (/already.*(auto-merge|enabled)/i.test(msg)) {
                  core.info(`#${number}: Auto-merge already enabled (noop).`);
                } else if (/Resource not accessible by integration/i.test(msg)) {
                  core.info(`#${number}: skip (fork or insufficient perms: ${msg})`);
                } else {
                  core.info(`#${number}: enable failed (${msg}). Will retry on next event.`);
                }
              }
            }
        env:
          numbers: ${{ steps.prs.outputs.numbers }}

      - name: Auto-merge diagnostics (state + reason)
        if: steps.prs.outputs.numbers != '[]'
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const nums = JSON.parse(process.env.numbers || '[]');

            const ql = `
              query($owner:String!, $repo:String!, $num:Int!) {
                repository(owner:$owner, name:$repo) {
                  pullRequest(number:$num) {
                    id
                    number
                    isDraft
                    mergeable
                    reviewDecision
                    autoMergeRequest { enabledAt }
                    baseRefName
                    headRefName
                  }
                }
              }
            `;

            let lines = [];
            for (const number of nums) {
              // REST: check if auto-merge is armed
              const { data: prRest } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              const armed = !!prRest.auto_merge;

              // GraphQL: mergeability signals
              const data = await github.graphql(ql, { owner, repo, num: number });
              const pr = data.repository.pullRequest;

              // Derive a human reason if not armed
              let reason = '';
              if (pr.isDraft) reason ||= 'draft';
              if (pr.mergeable === 'CONFLICTING') reason ||= 'merge conflicts';
              if (pr.reviewDecision === 'REVIEW_REQUIRED') reason ||= 'required review not approved';
              if (!armed && !reason) reason = 'auto-merge not enabled by API (check repo setting and branch protection)';

              const state = armed ? 'armed' : 'not armed';
              const msg = `PR #${number}: Auto-merge is ${state}; mergeable=${pr.mergeable}; draft=${pr.isDraft}; reviewDecision=${pr.reviewDecision || 'n/a'}; ${reason || 'ok'}`;
              core.info(msg);
              lines.push(msg);
            }

            await core.summary
              .addHeading('Auto-merge diagnostics', 3)
              .addList(lines)
              .write();
        env:
          numbers: ${{ steps.prs.outputs.numbers }}

      - name: Note auto-merge state in Summary
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const pr = context.payload.pull_request;
            const labels = (pr.labels || []).map(l => (l.name||'').toLowerCase());
            const armed = labels.includes('codex') && !labels.includes('no-automerge') && !pr.draft && pr.head.repo?.full_name === pr.base.repo?.full_name;
            const line = armed ? `Auto-merge: **armed** for #${pr.number} (Squash)` : `Auto-merge: **not armed** for #${pr.number}`;
            await core.summary.addRaw(line).write()
