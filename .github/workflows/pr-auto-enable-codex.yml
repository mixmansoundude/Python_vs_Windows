name: PR Auto-Enable Auto-merge (codex label)

on:
  pull_request:
    types: [opened, labeled, unlabeled, synchronize, reopened, ready_for_review]
  check_suite:
    types: [completed]
  status: {}

permissions:
  pull-requests: write
  contents: write

jobs:
  auto_enable_codex:
    runs-on: ubuntu-latest
    steps:
      - name: Resolve candidate PR numbers for this event
        id: prs
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            async function numbersFromEvent() {
              if (context.eventName === 'pull_request') {
                return [context.payload.pull_request.number];
              }
              // Map status/check_suite SHA â†’ PRs using stable REST API
              const sha =
                context.eventName === 'status'
                  ? context.payload.sha
                  : context.payload.check_suite?.head_sha;

              if (!sha) return [];
              const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner, repo, commit_sha: sha
              });
              return prs.filter(pr => pr.state === 'open').map(pr => pr.number);
            }

            const nums = await numbersFromEvent();
            core.setOutput('numbers', JSON.stringify(nums));

      - name: Enable Auto-merge (Squash) on eligible PRs (label=codex) via PAT
        if: steps.prs.outputs.numbers != '[]' && secrets.AUTOMERGE_TOKEN
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTOMERGE_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const nums = JSON.parse(process.env.numbers || '[]');
            const via = process.env.ENABLED_VIA ? ` via ${process.env.ENABLED_VIA}` : '';

            // Repo-level capability
            const repoQl = `
              query($owner:String!,$repo:String!){
                repository(owner:$owner,name:$repo){
                  id
                  autoMergeAllowed
                  squashMergeAllowed
                }
              }
            `;
            const repoData = await github.graphql(repoQl, { owner, repo });
            const repoAuto = repoData.repository.autoMergeAllowed ?? true; // older servers may not expose; assume true

            // PR-level capability + state
            const prQl = `
              query($owner:String!,$repo:String!,$num:Int!){
                repository(owner:$owner,name:$repo){
                  pullRequest(number:$num){
                    id
                    number
                    isDraft
                    mergeable
                    reviewDecision
                    viewerCanEnableAutoMerge
                    autoMergeRequest { enabledAt }
                    headRepository { nameWithOwner }
                    baseRepository { nameWithOwner }
                  }
                }
              }
            `;
            const enableMutation = `
              mutation($id:ID!){
                enablePullRequestAutoMerge(input:{pullRequestId:$id,mergeMethod:SQUASH}){ clientMutationId }
              }
            `;

            for (const number of nums) {
              const { data: prRest } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              const labels = (prRest.labels || []).map(l => (l.name||'').toLowerCase());
              const isSameRepo = prRest.head?.repo?.full_name === prRest.base?.repo?.full_name;

              // Maintain existing gates
              if (prRest.state !== 'open' || prRest.draft) { core.info(`#${number}: skip (closed/draft)`); continue; }
              if (!isSameRepo) { core.info(`#${number}: skip (fork PR)`); continue; }
              if (!labels.includes('codex')) { core.info(`#${number}: skip (missing 'codex' label)`); continue; }
              if (labels.includes('no-automerge')) { core.info(`#${number}: skip (has 'no-automerge')`); continue; }

              const data = await github.graphql(prQl, { owner, repo, num: number });
              const pr = data.repository.pullRequest;

              if (pr.autoMergeRequest?.enabledAt) {
                core.info(`#${number}: Auto-merge already enabled (noop).`);
                continue;
              }

              if (!repoAuto) {
                core.info(`#${number}: enable failed (repository.autoMergeAllowed=false). Check repo Settings -> Pull Requests -> Allow auto-merge.`);
                continue;
              }

              if (pr.isDraft) { core.info(`#${number}: skip (draft)`); continue; }

              if (!pr.viewerCanEnableAutoMerge) {
                core.info(`#${number}: enable failed (viewer cannot enable auto-merge). Check Actions -> Workflow permissions = Read & write; token must have write permission to pull requests.`);
                continue;
              }

              try {
                await github.graphql(enableMutation, { id: pr.id });
                core.info(`#${number}: Auto-merge enabled (Squash)${via}. GitHub will merge when required checks pass.`);
              } catch (e) {
                const raw = (e && e.errors) ? JSON.stringify(e.errors[0]) : String(e.message||e);
                core.info(`#${number}: enable failed (GraphQL): ${raw}`);
                core.info(`#${number}: Will retry on next event.`);
              }
            }
        env:
          numbers: ${{ steps.prs.outputs.numbers }}
          ENABLED_VIA: PAT

      - name: Enable Auto-merge (Squash) on eligible PRs (label=codex) via GITHUB_TOKEN
        if: steps.prs.outputs.numbers != '[]' && !secrets.AUTOMERGE_TOKEN
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const nums = JSON.parse(process.env.numbers || '[]');
            const via = process.env.ENABLED_VIA ? ` via ${process.env.ENABLED_VIA}` : '';

            // Repo-level capability
            const repoQl = `
              query($owner:String!,$repo:String!){
                repository(owner:$owner,name:$repo){
                  id
                  autoMergeAllowed
                  squashMergeAllowed
                }
              }
            `;
            const repoData = await github.graphql(repoQl, { owner, repo });
            const repoAuto = repoData.repository.autoMergeAllowed ?? true; // older servers may not expose; assume true

            // PR-level capability + state
            const prQl = `
              query($owner:String!,$repo:String!,$num:Int!){
                repository(owner:$owner,name:$repo){
                  pullRequest(number:$num){
                    id
                    number
                    isDraft
                    mergeable
                    reviewDecision
                    viewerCanEnableAutoMerge
                    autoMergeRequest { enabledAt }
                    headRepository { nameWithOwner }
                    baseRepository { nameWithOwner }
                  }
                }
              }
            `;
            const enableMutation = `
              mutation($id:ID!){
                enablePullRequestAutoMerge(input:{pullRequestId:$id,mergeMethod:SQUASH}){ clientMutationId }
              }
            `;

            for (const number of nums) {
              const { data: prRest } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              const labels = (prRest.labels || []).map(l => (l.name||'').toLowerCase());
              const isSameRepo = prRest.head?.repo?.full_name === prRest.base?.repo?.full_name;

              // Maintain existing gates
              if (prRest.state !== 'open' || prRest.draft) { core.info(`#${number}: skip (closed/draft)`); continue; }
              if (!isSameRepo) { core.info(`#${number}: skip (fork PR)`); continue; }
              if (!labels.includes('codex')) { core.info(`#${number}: skip (missing 'codex' label)`); continue; }
              if (labels.includes('no-automerge')) { core.info(`#${number}: skip (has 'no-automerge')`); continue; }

              const data = await github.graphql(prQl, { owner, repo, num: number });
              const pr = data.repository.pullRequest;

              if (pr.autoMergeRequest?.enabledAt) {
                core.info(`#${number}: Auto-merge already enabled (noop).`);
                continue;
              }

              if (!repoAuto) {
                core.info(`#${number}: enable failed (repository.autoMergeAllowed=false). Check repo Settings -> Pull Requests -> Allow auto-merge.`);
                continue;
              }

              if (pr.isDraft) { core.info(`#${number}: skip (draft)`); continue; }

              if (!pr.viewerCanEnableAutoMerge) {
                core.info(`#${number}: enable failed (viewer cannot enable auto-merge). Check Actions -> Workflow permissions = Read & write; token must have write permission to pull requests.`);
                continue;
              }

              try {
                await github.graphql(enableMutation, { id: pr.id });
                core.info(`#${number}: Auto-merge enabled (Squash)${via}. GitHub will merge when required checks pass.`);
              } catch (e) {
                const raw = (e && e.errors) ? JSON.stringify(e.errors[0]) : String(e.message||e);
                core.info(`#${number}: enable failed (GraphQL): ${raw}`);
                core.info(`#${number}: Will retry on next event.`);
              }
            }
        env:
          numbers: ${{ steps.prs.outputs.numbers }}
          ENABLED_VIA: GITHUB_TOKEN

      - name: Auto-merge diagnostics (state + reason)
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            async function resolvePRNumbers(){
              if (context.eventName === 'pull_request') return [context.payload.pull_request.number];
              const sha = context.eventName === 'status' ? context.payload.sha : context.payload.check_suite?.head_sha;
              if (!sha) return [];
              const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({ owner, repo, commit_sha: sha });
              return prs.filter(pr => pr.state === 'open').map(pr => pr.number);
            }

            const repoQl = `
              query($owner:String!,$repo:String!){
                repository(owner:$owner,name:$repo){
                  autoMergeAllowed
                }
              }
            `;
            const prQl = `
              query($owner:String!,$repo:String!,$num:Int!){
                repository(owner:$owner,name:$repo){
                  pullRequest(number:$num){
                    id number isDraft mergeable reviewDecision
                    viewerCanEnableAutoMerge
                    autoMergeRequest { enabledAt }
                  }
                }
              }
            `;

            const nums = await resolvePRNumbers();
            const lines = [];
            const repoData = await github.graphql(repoQl, { owner, repo });
            const repoAuto = repoData.repository.autoMergeAllowed;

            if (!nums.length) {
              const msg = `Auto-merge diagnostics: no open PRs found for event=${context.eventName}; repo.autoMergeAllowed=${repoAuto}`;
              core.info(msg); await core.summary.addRaw(msg).write(); return;
            }

            for (const number of nums) {
              const { data: prRest } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              const armed = !!prRest.auto_merge;
              const data = await github.graphql(prQl, { owner, repo, num: number });
              const pr = data.repository.pullRequest;

              let reason = '';
              if (!armed) {
                if (!repoAuto) reason ||= 'repo auto-merge disabled';
                if (pr.isDraft) reason ||= 'draft';
                if (pr.mergeable === 'CONFLICTING') reason ||= 'merge conflicts';
                if (pr.reviewDecision === 'REVIEW_REQUIRED') reason ||= 'required review not approved';
                if (!pr.viewerCanEnableAutoMerge) reason ||= 'actor cannot enable auto-merge (permissions)';
                if (!reason) reason = 'not enabled by API (see logs above)';
              }

              const state = armed ? 'armed' : 'not armed';
              const msg = `PR #${number}: Auto-merge is ${state}; repo.autoMergeAllowed=${repoAuto}; viewerCanEnable=${pr.viewerCanEnableAutoMerge}; mergeable=${pr.mergeable}; draft=${pr.isDraft}; reviewDecision=${pr.reviewDecision || 'n/a'}; ${reason || 'ok'}`;
              core.info(msg);
              lines.push(msg);
            }

            await core.summary.addHeading('Auto-merge diagnostics', 3).addList(lines).write();

      - name: Note auto-merge state in Summary
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const pr = context.payload.pull_request;
            const labels = (pr.labels || []).map(l => (l.name||'').toLowerCase());
            const armed = labels.includes('codex') && !labels.includes('no-automerge') && !pr.draft && pr.head.repo?.full_name === pr.base.repo?.full_name;
            const line = armed ? `Auto-merge: **armed** for #${pr.number} (Squash)` : `Auto-merge: **not armed** for #${pr.number}`;
            await core.summary.addRaw(line).write()
