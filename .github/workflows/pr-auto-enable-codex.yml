# yamllint disable rule:line-length
# yamllint disable rule:truthy
# Rationale: GitHub requires `status: {}` to subscribe broadly, and the embedded GraphQL/script blocks exceed 80 columns.
---
name: PR Auto-Enable Auto-merge (codex label)

on:
  pull_request:
    types: [opened, labeled, unlabeled, synchronize, reopened, ready_for_review]
  check_suite:
    types: [completed]
  status: {}

permissions:
  pull-requests: write
  contents: write

jobs:
  auto_enable_codex:
    runs-on: ubuntu-latest
    env:
      AUTOMERGE_TOKEN: ${{ secrets.AUTOMERGE_TOKEN }}
    steps:
      - name: Resolve candidate PR numbers for this event
        id: prs
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            async function numbersFromEvent() {
              if (context.eventName === 'pull_request') {
                return [context.payload.pull_request.number];
              }
              // Map status/check_suite SHA → PRs using stable REST API
              const sha =
                context.eventName === 'status'
                  ? context.payload.sha
                  : context.payload.check_suite?.head_sha;

              if (!sha) return [];
              const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner, repo, commit_sha: sha
              });
              return prs.filter(pr => pr.state === 'open').map(pr => pr.number);
            }

            const nums = await numbersFromEvent();
            core.setOutput('numbers', JSON.stringify(nums));

      - name: Comment for Codex review
        if: ${{ steps.prs.outputs.numbers != '[]' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const nums = JSON.parse(process.env.numbers || '[]');
            for (const number of nums) {
              try {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: number,
                  body: '@codex review'
                });
                core.info(`#${number}: posted "@codex review" comment`);
              } catch (error) {
                core.info(`#${number}: failed to post comment - ${error?.message || error}`);
              }
            }
        env:
          numbers: ${{ steps.prs.outputs.numbers }}

      - name: Enable Auto-merge (codex) via PAT
        if: ${{ steps.prs.outputs.numbers != '[]' && env.AUTOMERGE_TOKEN }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTOMERGE_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const nums = JSON.parse(process.env.numbers || '[]');
            core.info('Auth path: PAT (AUTOMERGE_TOKEN)');

            const ql = `
              query($owner:String!,$repo:String!,$num:Int!){
                repository(owner:$owner,name:$repo){
                  pullRequest(number:$num){
                    id number isDraft mergeable reviewDecision viewerCanEnableAutoMerge
                    autoMergeRequest { enabledAt }
                    headRepository { nameWithOwner } baseRepository { nameWithOwner }
                  }
                }
              }
            `;
            const enable = `
              mutation($id:ID!){
                enablePullRequestAutoMerge(input:{pullRequestId:$id,mergeMethod:SQUASH}){ clientMutationId }
              }
            `;

            for (const number of nums) {
              const { data: prRest } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              const labels = (prRest.labels || []).map(l => (l.name||'').toLowerCase());
              const isSameRepo = prRest.head?.repo?.full_name === prRest.base?.repo?.full_name;

              if (prRest.state !== 'open' || prRest.draft) { core.info(`#${number}: skip (closed/draft)`); continue; }
              if (!isSameRepo) { core.info(`#${number}: skip (fork PR)`); continue; }
              if (!labels.includes('codex')) { core.info(`#${number}: skip (missing 'codex' label)`); continue; }
              if (labels.includes('no-automerge')) { core.info(`#${number}: skip (has 'no-automerge')`); continue; }
              if (prRest.auto_merge) { core.info(`#${number}: already armed (REST)`); continue; }

              const pre = await github.graphql(ql, { owner, repo, num: number });
              const pr = pre.repository.pullRequest;
              if (!pr.viewerCanEnableAutoMerge) {
                core.info(`#${number}: PAT viewer cannot enable auto-merge (viewerCanEnable=false). Check PAT scopes (public_repo for public repo).`);
                continue;
              }

              try {
                await github.graphql(enable, { id: pr.id });
                const { data: after } = await github.rest.pulls.get({ owner, repo, pull_number: number });
                if (after.auto_merge) {
                  core.info(`#${number}: Auto-merge enabled (Squash) via PAT ✅`);
                } else {
                  core.info(`#${number}: enable via PAT reported success, but REST auto_merge is null (will rely on diagnostics).`);
                }
              } catch (e) {
                const msg = e?.errors ? JSON.stringify(e.errors[0]) : String(e.message||e);
                core.info(`#${number}: enable failed via PAT (GraphQL): ${msg}`);
              }
            }
        env:
          numbers: ${{ steps.prs.outputs.numbers }}

      - name: Enable Auto-merge (codex) via GITHUB_TOKEN
        if: ${{ steps.prs.outputs.numbers != '[]' && !env.AUTOMERGE_TOKEN }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const nums = JSON.parse(process.env.numbers || '[]');
            core.info('Auth path: GITHUB_TOKEN');

            const enable = `
              mutation($id:ID!){
                enablePullRequestAutoMerge(input:{pullRequestId:$id,mergeMethod:SQUASH}){ clientMutationId }
              }
            `;

            for (const number of nums) {
              const { data: prRest } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              const labels = (prRest.labels || []).map(l => (l.name||'').toLowerCase());
              const isSameRepo = prRest.head?.repo?.full_name === prRest.base?.repo?.full_name;

              if (prRest.state !== 'open' || prRest.draft) { core.info(`#${number}: skip (closed/draft)`); continue; }
              if (!isSameRepo) { core.info(`#${number}: skip (fork PR)`); continue; }
              if (!labels.includes('codex')) { core.info(`#${number}: skip (missing 'codex' label)`); continue; }
              if (labels.includes('no-automerge')) { core.info(`#${number}: skip (has 'no-automerge')`); continue; }
              if (prRest.auto_merge) { core.info(`#${number}: already armed (REST)`); continue; }

              try {
                await github.graphql(enable, { id: prRest.node_id || prRest.id /* node_id expected */ });
              } catch (e) {
                const msg = e?.errors ? JSON.stringify(e.errors[0]) : String(e.message||e);
                core.info(`#${number}: enable failed via GITHUB_TOKEN (GraphQL): ${msg}`);
                continue;
              }

              const { data: after } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              if (after.auto_merge) {
                core.info(`#${number}: Auto-merge enabled (Squash) via GITHUB_TOKEN ✅`);
              } else {
                core.info(`#${number}: enable via GITHUB_TOKEN reported success, but REST auto_merge is null (permissions likely).`);
              }
            }
        env:
          numbers: ${{ steps.prs.outputs.numbers }}

      - name: Auto-merge diagnostics (state + reason)
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            async function resolvePRNumbers(){
              if (context.eventName === 'pull_request') return [context.payload.pull_request.number];
              const sha = context.eventName === 'status' ? context.payload.sha : context.payload.check_suite?.head_sha;
              if (!sha) return [];
              const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({ owner, repo, commit_sha: sha });
              return prs.filter(pr => pr.state === 'open').map(pr => pr.number);
            }

            const repoQl = `
              query($owner:String!,$repo:String!){
                repository(owner:$owner,name:$repo){
                  autoMergeAllowed
                }
              }
            `;
            const prQl = `
              query($owner:String!,$repo:String!,$num:Int!){
                repository(owner:$owner,name:$repo){
                  pullRequest(number:$num){
                    id number isDraft mergeable reviewDecision
                    viewerCanEnableAutoMerge
                    autoMergeRequest { enabledAt }
                  }
                }
              }
            `;

            const nums = await resolvePRNumbers();
            const lines = [];
            const repoData = await github.graphql(repoQl, { owner, repo });
            const repoAuto = repoData.repository.autoMergeAllowed;

            if (!nums.length) {
              const msg = `Auto-merge diagnostics: no open PRs found for event=${context.eventName}; repo.autoMergeAllowed=${repoAuto}`;
              core.info(msg); await core.summary.addRaw(msg).write(); return;
            }

            for (const number of nums) {
              const { data: prRest } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              const armed = !!prRest.auto_merge;
              const data = await github.graphql(prQl, { owner, repo, num: number });
              const pr = data.repository.pullRequest;

              let reason = '';
              if (!armed) {
                if (!repoAuto) reason ||= 'repo auto-merge disabled';
                if (pr.isDraft) reason ||= 'draft';
                if (pr.mergeable === 'CONFLICTING') reason ||= 'merge conflicts';
                if (pr.reviewDecision === 'REVIEW_REQUIRED') reason ||= 'required review not approved';
                if (!pr.viewerCanEnableAutoMerge) reason ||= 'actor cannot enable auto-merge (permissions)';
                if (!reason) reason = 'not enabled by API (see logs above)';
              }

              const state = armed ? 'armed' : 'not armed';
              const msg = `PR #${number}: Auto-merge is ${state}; repo.autoMergeAllowed=${repoAuto}; viewerCanEnable=${pr.viewerCanEnableAutoMerge}; mergeable=${pr.mergeable}; draft=${pr.isDraft}; reviewDecision=${pr.reviewDecision || 'n/a'}; ${reason || 'ok'}`;
              core.info(msg);
              lines.push(msg);
            }

            await core.summary.addHeading('Auto-merge diagnostics', 3).addList(lines).write();

      - name: Note auto-merge state in Summary
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const pr = context.payload.pull_request;
            const labels = (pr.labels || []).map(l => (l.name||'').toLowerCase());
            const armed = labels.includes('codex') && !labels.includes('no-automerge') && !pr.draft && pr.head.repo?.full_name === pr.base.repo?.full_name;
            const line = armed ? `Auto-merge: **armed** for #${pr.number} (Squash)` : `Auto-merge: **not armed** for #${pr.number}`;
            await core.summary.addRaw(line).write()
